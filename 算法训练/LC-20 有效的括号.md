
>[!faq] 题目描述
>给定一个只包括 `'('`，`')'`，`'{'`，`'}'`，`'['`，`']'` 的字符串 `s` ，判断字符串是否有效。
>
有效字符串需满足：
>1. 左括号必须用相同类型的右括号闭合。
>2. 左括号必须以正确的顺序闭合。
>3. 每个右括号都有一个对应的相同类型的左括号。

>[!abstract] 示例 1
**输入：** `s = "()"`
**输出：** `true`

>[!abstract] 示例 2
**输入：** `s = "()[]{}"`
**输出：** `true`

>[!abstract] 示例 3
**输入：** `s = "(]"`
**输出：** `false`

>[!abstract] 示例 4
**输入：** `s = "([])"`
**输出：** `true`

>[!abstract] 示例 5
**输入：** `s = "([)]"`
**输出：** `false`

>[!warning] 提示
>- `1 <= s.length <= 104`
>- `s` 仅由括号 `'()[]{}'` 组成

**我的题解**

因为刚刚复习完顺序栈，因此首先我尝试使用顺序栈的原始结构进行解题，最终通过的代码如下：

```c
typedef struct{  
    char data[10000];  
    int top;  
}Stack;  
void init(Stack *st){st->top=0;}  
void push(Stack *st,char x){  
    st->data[st->top++]=x;  
}  
void pop(Stack *st){  
    st->top--;  
}  
char find(Stack st){  
    if (st.top==0) return ' ';  
    return st.data[st.top-1];  
}  
bool isValid(char* s) {  
    Stack st;  
    init(&st);  
    int i=0;  
    while (s[i]!='\0'){  
        switch (s[i]){  
            case '[':  
            case '{':  
            case '(':  
                push(&st,s[i]);  
                break;  
            case ')':  
                if (find(st)=='('){pop(&st);break;}  
                else return false;  
            case ']':  
                if (find(st)=='['){pop(&st);break;}  
                else return false;  
            case '}':  
                if (find(st)=='{'){pop(&st);break;}  
                else return false;  
        }i++;  
    }  
    return st.top==0?true:false;  
}
```

根据栈的思想，我简化的上述代码，通过的简化代码如下：

```c
bool isValid(char* s) {  
    char data[10000];  
    int j=0;  
    for (int i=0;i<strlen(s);i++){  
        if (s[i]=='[' || s[i]=='{' || s[i]=='('){  
            data[j++]=s[i];  
        }else if(s[i]==')'){  
            if(j!=0&&data[j-1]=='(') j--;  
            else return false;  
        }else if(s[i]==']'){  
            if(j!=0&&data[j-1]=='[') j--;  
            else return false;  
        }else if(s[i]=='}'){  
            if(j!=0&&data[j-1]=='{') j--;  
            else return false;  
        }  
    }  
    return j==0?true:false;  
}
```

但是这两种算法设计的时间和空间复杂度都不太理想，需要继续优化！

**官方题解——栈**

```c
char pairs(char a) {  
    if (a == '}') return '{';  
    if (a == ']') return '[';  
    if (a == ')') return '(';  
    return 0;  
}  
  
bool isValid(char* s) {  
    int n = strlen(s); 
    // 若为奇数，则一定不对称 
    if (n % 2 == 1) {  
        return false;  
    }  
    int stk[n + 1], top = 0;  
    // stk使用n+1来确定长度，有效地提高了空间利用率
    for (int i = 0; i < n; i++) {
        char ch = pairs(s[i]);  
        // 非反括号则为假
        if (ch) {  
            if (top == 0 || stk[top - 1] != ch) {  
                return false;  
            }  
            top--;  
        } else {  
            stk[top++] = s[i];  
        }  
    }  
    return top == 0;  
}
```

>[!tip] 复杂度分析
**时间复杂度**：O(n)，其中 n 是字符串 s 的长度。
**空间复杂度**：O(n+∣Σ∣)，其中 Σ 表示字符集，本题中字符串只包含 6 种括号，∣Σ∣=6。栈中的字符数量为 O(n)，而哈希表使用的空间为 O(∣Σ∣)，相加即可得到总空间复杂度。
