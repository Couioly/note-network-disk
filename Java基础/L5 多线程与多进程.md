在应用程序中，将**多个程序块同时运行**的现象称为**并发执行**。**多线程**是指一个应用程序中有**多条并发执行**的线索，每条线索被称为一个**线程**。它们交替执行，彼此间可以进行通信。

## 1 线程与进程

一台计算机可以同时执行多个程序，而这**每个运行中的程序**都是**一个进程**，每个进程都拥有相对**独立的执行环境**。进程时程序的实例，时操作系统动态执行的**基本单元**。

**进程**的实质是程序在多到程序系统中的**一次执行过程**，但进程中的**实际运作单位是线程**。线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中。**一个进程中至少存在一个线程**，每一个线程都是进程中一个单一顺序的控制流。

**多线程程序**是指程序中实现多段程序代码**交替运行**的效果。创建线程的方式有以下3种：

- 继承`Thread`类
- 实现`Runnable`接口
- 基于`Callable`接口和`Future`类

**接下来实现判断指定列表中年份的平闰年**

#### 1.1 继承 Thread 类创建

编写多线程程序，需要在程序中创建并启动**除主线程之外**的**其他线程**，Java中使用`Thread`类来代表线程，所有的**线程对象**都必须是`Thread`类或其子类的实例。`Thread`类用于**分配线程对象的构造方法**：

| 方法声明                                  | 说明                                   |
| ------------------------------------- | ------------------------------------ |
| `Thread()`                            | 创建一个线程对象                             |
| `Thread(String name)`                 | 创建一个名称为name的线程对象                     |
| `Thread(Runnable target)`             | 根据任务对象target创建一个线程对象                 |
| `Thread(Runnable target,String name)` | 根据任务对象target创建一个线程对象，并指定线程对象的名称为name |
>[!warning] 注意
>若未指定线程名字，程序会自动为线程分配格式为 `Thread-n` 的名称，n为非负整数的数字。

Thread类提供的常用于**操作线程**的方法如下：

| 方法声明                             | 说明                   |
| -------------------------------- | -------------------- |
| `String getName()`               | 获取当前线程的名称            |
| `void setName(String name)`      | 将当前线程的名称更改为参数name    |
| `void start()`                   | 启动一个新线程              |
| `void run()`                     | 线程的执行方法，是线程执行的主体     |
| `static void sleep(long millis)` | 使当前正在执行的线程休眠millis毫秒 |
>[!warning] 注意事项
>1. `start()`方法用于**启动一个新线程**，但是该方法本身**并不是执行线程代码**的方法。`start()`方法只能告诉JVM该线程已准备好被执行，并由JVM来负责调度和执行；
>2. 当线程获得了CPU时间片后，就会调用该线程的`run()`方法，该方法是线程的**执行方法**，其中包含线程的**主要执行逻辑**；
>3. 若直接调用`run()`方法，则该方法**并不会启动线程**，只是在**当前线程**中执行了`run()`方法中的代码而已。

**通过Thread类创建线程步骤**：

1. 首先定义通用的闰年判断规则：
```java
public class LeapYearUtil {  
    /**  
     * 判断单个年份是否为闰年  
     * 规则：能被4整除但不能被100整除，或能被400整除  
     */  
    public static boolean isLeapYear(int year) {  
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);  
    }  
}
```

2. 定义`Thread`类的子类，并重写Thread类的`run()`方法，在`run()`方法中定义线程要执行的任务；

```java
// 单个年份的闰年判断线程  
class LeapYearThread extends Thread {  
    private int year;  
  
    public LeapYearThread(int year) {  
        this.year = year;  
    }  
  
    @Override  
    public void run() {  
        boolean result = LeapYearUtil.isLeapYear(year);  
        System.out.printf("线程[%s]：年份%d %s闰年%n",  
                Thread.currentThread().getName(), year, result ? "是" : "不是");  
    }  
}
```

>[!bug] 异常处理
>`sleep()`可能导致`InterruptedException`异常！

3. 创建Thread子类的实例，即创建**线程对象**；
4. 调用线程对象的`start()`的方法启动线程。

```java
// 测试类  
public class LeapYearThreadDemo {  
    public static void main(String[] args) {  
        // 待判断的年份数组  
        int[] years = {2000, 2020, 2024, 1900, 2025};  
  
        // 为每个年份创建线程并启动  
        for (int year : years) {  
            new LeapYearThread(year).start();  
        }  
    }  
}
```

运行结果：

```
线程[Thread-0]：年份2000 是闰年
线程[Thread-1]：年份2020 是闰年
线程[Thread-4]：年份2025 不是闰年
线程[Thread-3]：年份1900 不是闰年
线程[Thread-2]：年份2024 是闰年
```

#### 1.2 实现 Runnable 接口创建

Java是**单继承**，因此若继承其他父类时将无法通过继承 `Thread` 类进行创建线程，因此，可以借助`Thread`类提供的`Thread(Runnable target)` 或 `Thread(Runnable target, String name)`构造方法来创建线程，其中`Runnable`接口的实例代表一个需要执行的具体任务，通常被称为**任务对象**，`Runnable`接口只包含一个`run()`方法，用于**定义线程的执行代码**。

**通过实现Runnable接口创建多线程的步骤**：

1. 首先定义通用的闰年判断规则：

```java
public class LeapYearUtil {  
    /**  
     * 判断单个年份是否为闰年  
     * 规则：能被4整除但不能被100整除，或能被400整除  
     */  
    public static boolean isLeapYear(int year) {  
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);  
    }  
}
```

2. 定义`Runnable`接口的实现类，并重写该接口`run()`方法；

```java
// 闰年判断任务（实现Runnable）  
class LeapYearTask implements Runnable {  
    private int year;  
  
    public LeapYearTask(int year) {  
        this.year = year;  
    }  
  
    @Override  
    public void run() {  
        boolean result = LeapYearUtil.isLeapYear(year);  
        System.out.printf("线程[%s]：年份%d %s闰年%n",  
                Thread.currentThread().getName(), year, result ? "是" : "不是");  
    }  
}
```

3. 创建`Runnable`实现类的实例，并将实例作为`Thread`的任务对象**创建Thread对象**；
4. 调用线程对象的`start()`方法启动线程。

```java
// 测试类  
public class LeapYearRunnableDemo {  
    public static void main(String[] args) {  
        int[] years = {2000, 2020, 2024, 1900, 2025};  
  
        // 为每个任务分配线程  
        for (int year : years) {  
            Thread thread = new Thread(new LeapYearTask(year));  
            thread.start();  
        }  
    }  
}
```

运行结果：

```
线程[Thread-0]：年份2000 是闰年
线程[Thread-4]：年份2025 不是闰年
线程[Thread-2]：年份2024 是闰年
线程[Thread-3]：年份1900 不是闰年
线程[Thread-1]：年份2020 是闰年
```

#### 1.3 实现 Callable 接口创建

通过实现`Runnable`接口创建线程时，将重写的`run()`方法包装成**线程执行体**，由于`run()`方法**没有返回值**，因此如果线程执行结果需要返回值时，实现`Runnable`接口的方式将不适用。此时，可使用`Callable`接口，该接口的`call()`方法可以作为线程的执行体，并且**有返回值**。

>[!warning] 提示
>`Callable`对象不能直接作为`Thread`构造方法的`target`参数，需要借助`FutureTask`类创建对应的参数对象，`FutureTask`类提供的构造方法可以传入一个`Callable`对象对其封装起来，作为创建`Thread`对象时的`target`参数值。当线程执行时，`FutureTask`内部会执行`Callable`对象的`call()`方法，并将结果存储在`FutureTask`中。

`Future`接口管理线程的5个方法：

| 方法声明                                            | 功能描述                                                                                 |
| ----------------------------------------------- | ------------------------------------------------------------------------------------ |
| `boolean cancel(boolean mayInterruptIfRunning)` | 用于尝试取消任务，参数`mayInterruptIfRunning`表示**是否允许取消正在执行却没有执行完毕的任务**，如果设置true，则表示可以取消正在执行的任务 |
| `boolean isCancelled()`                         | 判断任务是否被取消，如果被取消返回true，否则返回false                                                      |
| `boolean isDone()`                              | 判断任务是否已经完成，如果任务完成返回true，否则返回false                                                    |
| `V get()`                                       | 用于获取执行结果，这个方法**会发生阻塞**，一直等到任务行完毕才返回执行结果                                              |
| `V get(long timeout, TimeUnit unit)`            | 用于在指定时间内获取执行结果，如果在指定时间内无法获取到结果则抛出异常                                                  |
**基于Callable和FutureTask创建线程的步骤：**

1. 首先定义通用的闰年判断规则：

```java
public class LeapYearUtil {  
    /**  
     * 判断单个年份是否为闰年  
     * 规则：能被4整除但不能被100整除，或能被400整除  
     */  
    public static boolean isLeapYear(int year) {  
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);  
    }  
}
```

2. 创建`Callable`接口的实现类；

```java
import java.util.concurrent.Callable;  
  
// 带返回值的闰年判断任务  
class LeapYearCallable implements Callable<String> {  
    private int year;  
  
    public LeapYearCallable(int year) {  
        this.year = year;  
    }  
  
    @Override  
    public String call() throws Exception {  
        boolean result = LeapYearUtil.isLeapYear(year);  
        // 返回任务结果（自定义格式）  
        return String.format("年份【%d】：%s闰年", year, result ? "是" : "不是");  
    }  
}
```

3. 创建包装了`Callable`对象的`FutureTask`类；
4. 使用`FutureTask`对象作为Thread对象的target参数并启动线程。

```java
import java.util.concurrent.FutureTask;

public class LeapYearFutureTaskDemo {  
    public static void main(String[] args) throws Exception {  
        // 待判断的年份数组  
        int[] years = {2000, 2020, 2024, 1900, 2025};  
  
        for (int year : years) {  
            // 1. 创建Callable任务对象  
            Callable<String> callable = new LeapYearCallable(year);  
  
            // 2. 用FutureTask包装Callable（FutureTask实现了RunnableFuture接口）  
            FutureTask<String> futureTask = new FutureTask<>(callable);  
  
            // 3. 创建线程并启动（FutureTask作为Runnable传入Thread）  
            Thread thread = new Thread(futureTask, "闰年判断线程-" + year);  
            thread.start();  
  
            // 4. 获取任务结果（get()会阻塞直到任务完成）  
            String result = futureTask.get();  
            System.out.println("线程[" + thread.getName() + "]结果：" + result);  
        }  
    }  
}
```

运行结果：

```
线程[闰年判断线程-2000]结果：年份【2000】：是闰年
线程[闰年判断线程-2020]结果：年份【2020】：是闰年
线程[闰年判断线程-2024]结果：年份【2024】：是闰年
线程[闰年判断线程-1900]结果：年份【1900】：不是闰年
线程[闰年判断线程-2025]结果：年份【2025】：不是闰年
```

| 创建方式                  | 优点                                                             | 缺点                                                                       |
| --------------------- | -------------------------------------------------------------- | ------------------------------------------------------------------------ |
| 继承Thread类             | 编码相对简单                                                         | 1. 存在单继承的局限性，不便于扩展<br/>2. 不能返回线程执行的结果<br/>3. 每个线程的任务和线程本身是耦合的，无法将任务和线程分离 |
| 实现Runnable接口          | 1. 可以继续继承类和实现接口，扩展性强<br/>2. 任务和线程分离，可以实现多个线程共享同一个任务            | 编码相对复杂，不能返回线程执行的结果                                                       |
| 基于Callable和FutureTask | 1. 线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。<br/>2. 可以在线程执行完毕后去获取线程执行的结果。 | 编码相对复杂                                                                   |
## 2 线程生命周期

线程生命周期的**六种基本状态**：

- 新建状态
- 可运行状态
- 阻塞状态
- 无限等待状态
- 计时等待状态
- 被终止状态

#### 2.1 新建状态 

创建一个线程对象，但还没调用**start()方法**启动线程，该线程就处于**新建状态**。此时，新建状态的线程和其他声明但未赋值的Java对象类似，JVM**仅为其分配了内存**，并没有表现出任何**线程的动态特征**。 

#### 2.2 可运行状态 

当线程对象调用了**start()方法**后就进入**可运行状态**，也称为**就绪状态**。处于可运行状态的线程位于**线程队列**中，此时它只是具备了运行的**条件**，要获得**CPU的使用权**并开始运行，还需要等待系统的**调度**。 

#### 2.3 阻塞状态 

如果处于**可运行状态**的线程获得了**CPU的使用权**，并开始执行**run()方法**中的线程执行体，则线程**处于运行状态**。 一个线程启动后，它可能不会一直处于运行状态，当一个线程试图获取一个**对象锁**，而该对象锁被**其他的线程**持有时，则该线程进入**阻塞状态**。当其他线程**释放对象锁**，该线程获得对象锁时，该线程将重新变成**可运行状态**。 

#### 2.4 无限等待状态 

一个线程在等待另一个线程执行一个**唤醒**动作时，该线程进入**无限等待状态**。线程进入这个状态后是不能**自动唤醒**的，必须等待另一个线程**调用notify()方法或者notifyAll()方法**才能够唤醒。 

#### 2.5 计时等待状态 

计时等待状态是指线程在调用了具有指定等待时间的方法后而进入的状态，这些方法包括**Thread类的sleep()方法和join()方法、Object类的wait()方法、LockSupport类的parkNanos()方法、LockSupport.parkUntil()** 等。 当线程调用这些方法并指定了等待时间，它就会进入**计时等待状态**，这一状态将一直保持到**超时**或者接收到**唤醒通知**。

#### 2.6被终止状态 

被终止状态是终止运行的线程的状态。线程因为**run()方法**正常退出，或者线程抛出一个**未捕获的异常(Exception)或者错误(Error)** 时终止了**run()方法**而结束执行。

在多线程程序中，CPU会在多个线程之间**切换执行**，因此，线程的状态会在**可运行**和**阻塞**之间切换，通过一些操作也可以使线程在**不同状态之间转换**。

![](./images/file-20251124215955204.png)

## 3 线程同步

**线程同步**指在一个多线程程序中，当一个线程在对内存中的**共享数据**进行操作时，**其他线程**无法对该**共享数据**进行操作的机制。该机制可以**确保多个线程按照特定顺序正确执行**，从而保证在多线程环境下共享资源的**安全访问**和**正确性**。

>[!bug] 提示
>1. 当程序中的线程**不同步**时，可能会导致线程出现**安全问题**
>2. 由于线程调度具有一定的**随机性**，当多个线程**同时**访问和操作**同一个共享资源**时，很容易出现偶然的**线程安全问题**

>[!faq] 什么是线程安全问题？
>指多线程环境中，多个线程**同时**访问共享数据，如果没有适当的**同步保护机制**保护共享数据，导致程序可能出现**不正确**或**不符合预期**的结果

#### 3.1 案例：银行取钱

**通过一个实例进行理解——银行取钱**。银行取钱的基本流程：

1. 用户输入取款金额；
2. 银行判断账户余额是否大于取款金额；
3. 若余额大于取款金额，则取款成功，否则失败。

实现步骤：
1）定义账户类Account，该类中包含账户编号和账户余额两个属性，以及取钱的方法；

```java
public class Account {  
    private String cardId;  
    private double money;  
    public Account(String cardId,double money){  
        this.cardId=cardId;  
        this.money=money;  
    }  
	public void drawMoney(double money){  
		if (this.money >= money) {  
			this.money -= money;  
			System.out.println(Thread.currentThread().getName() + "取钱成功，取出：" + money + "元，余额：" + this.money + "元");  
		} else {
		System.out.println(Thread.currentThread().getName() + "取钱失败")
		}
	}
    // ...setter/getter方法  
}
```

2）定义取钱的线程类，在该线程类的线程执行体中执行取钱操作，每次取100000元；

```java
public class DrawThread extends  Thread{  
    private Account acc;  
    public DrawThread(Account acc,String name){  
        super(name);  
        this.acc = acc;  
    }  
    @Override  
    public void run(){  
        acc.drawMoney(100000);  
    }  
}
```

3）创建测试类，在测试类的main()方法中创建账户对象，并启动两个线程从该账户中取钱；

```java
public class ThreadDemo {  
    public static void main(String[] args) {   
        Account acc = new Account("ICBC-111",100000);  
        new DrawThread(acc,"小明").start();  
        new DrawThread(acc,"小红").start();  
    }  
}
```
未添加线程同步的运行结果，根据结果可以看出并非为预想的结果：

```
小红取钱成功，取出：100000.0元，余额：-100000.0元
小明取钱成功，取出：100000.0元，余额：-100000.0元
```

#### 3.2 线程同步的实现

多线程程序中，多个线程**并发修改**共享资源时，可能会导致出现**线程安全问题**，而采用**线程同步机制**可以避免出现此类问题，线程同步的核心思想是保证在**任何时刻，只有一个线程**可以**访问共享资源**。同步线程的方式有3种：

- 同步代码块
- 同步方法
- Lock锁

##### **同步代码块**

同步代码块是一段被 `synchronized` 关键字修饰的代码块，可以将**处理共享资源的代码**放在同步代码块中，以保证在**同一时间**只有**一个线程**可以执行该代码中的内容，实现**线程同步**。其语法格式：

```java
synchronized(obj){
	...此处编写操作共享资源的代码
}
```

- `obj`：指一个对象，作为**锁**使用，只有**持有该锁**的线程才**可以执行**同步代码块中的代码，可以为任意一个**对象**，也可以是类的**字面常量**。
- 当某个线程执行同步代码块时，其他线程将无法执行当前同步代码块，进入**阻塞状态**。当前线程执行完同步代码块后，再与其他线程重新抢夺CPU的执行权，抢到CPU执行权的线程将进入同步代码块执行代码。

下面将修改取钱案例中的`drawMoney()`方法，将取钱的操作放入同步代码块中，如下：

```java
public void drawMoney(double money) {  
    synchronized ("") {  
        if (this.money >= money) {  
            this.money -= money;  
            System.out.println(Thread.currentThread().getName() + "取钱成功，取出：" + money + "元，余额：" + this.money + "元");  
        } else {  
            System.out.println(Thread.currentThread().getName() + "取钱失败");  
        }  
    }  
}
```

同步代码块的线程同步方式运行结果：

```
小明取钱成功，取出：100000.0元，余额：0.0元
小红取钱失败
```

##### **同步方法**

`synchronized` 关键字还可以用于**修饰方法**，称为**同步方法**。对于**实例**同步方法，默认使用**当前实例对象**作为锁对象，而对于**静态**同步方法，则默认使用**类对象**作为锁对象，即使用**类名.class对象**作为锁对象。具体语法如下：

```java
[修饰符] synchronized 返回值类型 方法名([参数1,...]){}
```

下面将修改取钱案例中的`drawMoney()`方法，将取钱的方法改为同步方法，如下：

```java
public synchronized void drawMoney(double money) {  
    if (this.money >= money) {  
        this.money -= money;  
        System.out.println(Thread.currentThread().getName() + "取钱成功，取出：" + money + "元，余额：" + this.money + "元");  
    } else {  
        System.out.println(Thread.currentThread().getName() + "取钱失败");  
    }  
}
```

同步方法的线程同步方式运行结果：

```
小明取钱成功，取出：100000.0元，余额：0.0元
小红取钱失败
```

##### Lock锁

>[!tips] 前引
>**同步代码块**和**同步方法**使用的是**封闭式**的锁机制，使用简单但存在限制，如**等待获取锁的线程/无法中断其等待**。这将会导致**系统资源的浪费**。

使用 `Lock` 接口相应的**实现类**充当**同步锁**来实现同步。**Lock对象**可以让某个线程在持续获取同步锁**失败后返回**，而**不再继续等待**，提供了更广泛的锁操作。

Lock是接口不能直接实例化，常用的是Lock接口的实现类`ReentrantLock`（**可重入锁**）。使用Lock对象可以**显式地加锁、释放锁**，加锁地方法为`lock()`，释放锁地方法为`unlock()`。使用该方式地具体代码如下：

```java
class 类名{
	// 定义锁对象
	private ReentrantLock reentrantLock = new ReentrantLock();
	// 需要保障线程安全的方法
	public void 方法名() {
		reentrantLock.lock(); // 加锁
		try {
			// 需要保证线程安全的代码
			...
		} finally {
			reentrantLock.unlock(); // 释放锁
		}
	}
}
```

下面将修改取钱案例中的`drawMoney()`方法，将取钱的方法使用`ReentrantLock`进行加锁，如下：

```java

```