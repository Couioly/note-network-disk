
### 背景及启蒙

今天接到老师通知，我们需要自主学习人工智能的相关课程，学习通关后需要进行学习认证，期限10天，10天后将截止。这对于我这种不爱学习的人来说好比水课，因为这段时间刚好临近期末考试，即将进入复习周，在这个节骨眼上给我们布置与期末考试无关的任务，要求必须刷够32学时，谁会认真去看？肯定第一想法便是挂后台，让它自己去刷！

![[Pasted image 20250627182042.png]]

在尝试挂后台操作后发现了问题——视频播放过程中会弹出一些题目，对当前的题目不进行选择提交的话视频将一直停留在当前进度。因此必须一直注视着屏幕，在弹出问题时要进行选择提交操作。在不断尝试的过程中，我发现对于这些题目，我可以不需进行选项选择而直接提交，再点击继续学习即可继续当前视频的进度。这好比在提交按钮的位置连续点击两次。

既然这样，那我可不可以运用pyautogui模块知识进行自动化操作呢？说干就干，询问AI，了解一下屏幕自定义图片查找的相关知识点，便开始了源程序设计！

### pyautogui.locateOnScreen()函数

`locateOnScreen(image,confidence,grayscale,region,maxSearchTime,minSearchTime,step,logSreenshot)`

参数介绍：
- image：必填参数，即所需查找的图片路径（可为PIL.Image对象）
- confidence：匹配置信度（0.0~1.0依次由低到高）
- grayscale：是否转为灰度图匹配，默认False（灰度图提高速度但降低精度）
- region：搜索区域，限制格式为`(left,top,width,height)`，提升效率
- maxSearchTime：最大搜索时间，默认无限制，设置后超时会抛出异常
- minSearchTime：最小搜索时间，即在搜索时间范围内查询多个目标
- step：搜索步长，默认为1，增大步长可加速搜索，但可能漏检小区域目标
- logScreenshot：是否记录搜索时屏幕截图，默认为False，开启后会输出调试信息

### 源码设计

首先按照以往惯例，先导包。

此处涉及到三个模块：
1. pyautogui：用于自动化操作鼠标键盘
2. time：用于控制休眠状态
3. datetime：用于查看当前时间

```python
import pyautogui as pag
from datetime import datetime
import time
```

接下来，需要提前准备好一个需要查找的内容图片文件，例如：`index.png`

```python
	img = './index.png'  # 这里的“index.png”是需要查找的图片文件
```

然后开始设计查找点击函数体，即`find_click()`函数

设计思路：
1. 使用`locateOnScreen()函数`识别屏幕并返回查找到的内容信息
2. 根据查找的返回信息确定目标的中心位置并进行操作
3. 对函数体进行异常处理设置

```python
def find_click(img :str, confidence :float=0.7)-> bool:  
    """  
    在屏幕上查找图片并点击  
    参数:  
        image_path (str): 要查找的图片路径  
        confidence (float): 匹配置信度(0-1)  
    返回值：  
        bool型  
    """    
    now_time = datetime.now().strftime("%Y-%m-%d %H:%M:%S")  
    try:  
        position = pag.locateOnScreen(img,confidence=0.7)  
        # 判断是否查找到目标信息  
        if position is not None:  
            # 对目标进行处理操作  
            time.sleep(2)  
            global n  
            n += 1  
            center_x = position.left + position.width / 2  
            center_y = position.top + position.height / 2  
            pag.click(center_x, center_y, 2, 1)  
            print(f"[{now_time}] 第{n}次点击提交按钮！")  
            return True  
        else:  
            return False  
    except pag.ImageNotFoundException:  
        print(f"[{now_time}] 未找到图片信息！")  
        return False  
    except Exception as e:  
        print(f"[{now_time}] 发生错误：{str(e)}")  
        return False
```

最后就是进行函数的调用，这里我属于入门，所以就是使用`while True`死循环进行无限调用吧！

```python
if __name__ == '__main__':
	n = 0  # 初始化累加器
	img = './index.png'  # 这里的“index.png”是需要查找的图片文件
	confidence = 0.7
	print("------------按钮识别（Ctrl+C退出程序）------------")
	while True:
		if find_click(img,confidence):
			print("---------点击成功-------120s后重新识别--------")
			time.sleep(120)
		else:
			print("---------------120s后重新识别---------------")
			time.sleep(120)
```

在经过一系列的调试运行后，代码目前可以正常执行了！（下图为正常执行后的结果）

![[Pasted image 20250623225731.png]]

### 代码优化

在每次终止程序时它都会显示报错，因此我可以为它添加一个异常处理，这样可以在退出程序时正常退出。在终端显示操作结果感觉很不方便，要是有一个可视化界面该多好！此时大脑灵机一闪，我想起了我们学过的Tkinter模块。在可视化界面中进行数据的更新，再将界面置顶，再为它做一个类似于日志的界面，方便查看识别记录的时间，说到时间，我们在等待重新调用函数的过程中，如果能够显化的看见时间的进度条，那样将更有意思。现在功能了解了，现在就只剩实现这些设想的功能了！

整理一下需实现的功能：
1. 添加退出的异常处理
2. 制作一个界面
3. 做一个可以更新数据的label
4. 设计一个可以累加记录的显示框
5. 添加一个进度条用于表示时间的等待过程

首先是退出时的报错处理 `KeyboardInterrupt` ，修改下面的代码块：

```python
if __name__ == '__main__':
	n = 0  # 初始化累加器
	print("------------按钮识别（Ctrl+C退出程序）------------")
	try:
		while True:
			...不需改动的部分源程序...
	except KeyboardInterrupt:  
	    print("程序已退出")
```

接下来制作一个可视化界面，设定一定的大小，窗口设置为置顶，当然在制作窗口前一定要使用`import tkinter`进行导包。实现的代码块如下：

```python
import tkinter
root = tkinter.Tk()  
root.title("课程自动化")  
root.geometry("500x400")  
root.attributes('-topmost', True)  
root.resizable(True, True)
root.mainloop()
```

现在我需要使用几个Label、Entry、Button组件对界面进行划分说明，代码如下所示：

```python
tkinter.Label(root, text="课程自动化", font=("隶书", 20)).place(x=180, y=20)  
tkinter.Label(root, text="Input匹配度0(弱)-1(强)之间：", font=("隶书", 16)).place(x=20, y=80)  
confidence = tkinter.StringVar(value="0.8")  
tkinter.Entry(root, textvariable=confidence, width=4, font=("宋体", 16)).place(x=400, y=80)  
tkinter.Label(root, text="Push图片路径：", font=("隶书", 16)).place(x=20, y=150)  
info = tkinter.Label(root, text="等待开始...",fg="red", font=("隶书", 10))  
info.place(x=140, y=250)  
path = tkinter.Label(root, text=img, font=("Consolas", 10), wraplength=480, justify="left")  
path.place(x=10, y=210)   
```

在定义及划分好区域时，便可以为界面添加用户交互按钮，我目前打算设定三个按钮

它们的名称及作用如下：
1. select路径：用来选择目标文件的路径，按钮绑定了文件路径选择函数`select_path()`
2. start刷课：用来在屏幕识别是否存在与目标文件所匹配的图片信息，该按钮绑定了查询界面的函数`find_click()`
3. 日志记录：用来查看已查询的结果状态及时间，按钮绑定了函数`message()`

```python
tkinter.Button(root, text="Select路径", fg="blue", font=("宋体", 14), command=select_path).place(x=250, y=145)  
tkinter.Button(root, text="日志记录", fg="green", font=("宋体", 16),command=message).place(x=280, y=320)  
tkinter.Button(root, text="Start刷课", fg="red", font=("宋体", 16),command=lambda: find_click(img, float(confidence.get()))).place(x=80, y=320) 
```

对于目标文件路径的上传函数，它主要的功能是通过用户上传文件`filedialog.askopenfilename`而获取到文件的绝对路径，但是在代码调试的过程中，我发现我的图片文件在绝对路径的情况下将一直报错无法读取到文件，在尝试后但无法解决时，我打算换种思路，既然不能用绝对路径，那我就直接将文件的路径限制为只能上传当前目录下的文件，再将获取到的路径进行格式化处理后将得到文件的相对路径，这样代码便可以正常执行！于是便有了下面的代码：

```python
def select_path():  
    info.config(text="正在读取识别信息...")  
    global img  
    # 设置文件类型过滤器，只显示图片文件  
    filetypes = (  
        ('图片文件', '*.png *.jpg *.jpeg *.bmp'),  
        ('所有文件', '*.*')  
    )  
    default_path = os.getcwd()  # 获取当前执行文件所在的目录 
    selected = filedialog.askopenfilename(filetypes=filetypes,initialdir=default_path)  
    # 确保用户选择了文件  
    if selected:  
        # 对路径进行格式化处理  
        img = selected.replace('\\', '/')  
        lis_path = (img.split('/'))  
        img = "./" + lis_path[-1]  # 转化为相对路径
        lis_path.pop(-1)  
        s = "/".join(lis_path)  
        # 判断文件路径是否在当前目录下  
        if default_path.replace('\\','/') != s:  
            messagebox.showerror("错误", f"技术缺陷，仅支持当前目录下的图片！")  
            img=''  
            return  
        # 更新可视化界面的组件显示内容
        path.config(text=selected)  
        info.config(text="读取成功！等待开始...")  
        print(f"选择的图片路径: {img}")  # 调试输出
```

到目前为止，还缺一个`message()`函数，这个函数用来显示日志，因此我打算还是老组合**子窗口+画布+容器+滚轮+消息内容**，再将画布与滚轮绑定，实现一个简单的记录展示功能。展示的数据内容怎么进行存储展示呢？用数据库？太麻烦了，简单点，直接使用一个列表用来当作容器，再每次执行一次查询操作，将该操作的执行结果存入列表，在下次打开画布时对内容进行更新，便实现了记录显示的功能。设计代码如下：

```python
def message():  
    try:  
        win = tkinter.Toplevel(root)  
        win.title("查找记录")  
        win.geometry("400x300+500+200")  
        win.attributes('-topmost', True)  
        # 创建Canvas  
        canvas = tkinter.Canvas(win)  
        canvas.pack(side=tkinter.LEFT, fill=tkinter.BOTH, expand=True)  
        # 创建Scrollbar  
        scrollbar = tkinter.Scrollbar(win, orient=tkinter.VERTICAL, command=canvas.yview)  
        scrollbar.pack(side=tkinter.RIGHT, fill=tkinter.Y)  
        # 关联Canvas和Scrollbar  
        canvas.configure(yscrollcommand=scrollbar.set)  
        # 创建Frame用于放置内容  
        frame = tkinter.Frame(canvas)  
        canvas.create_window((10, 10), window=frame, anchor=tkinter.NW)  
        # 向Frame中添加内容  
        for i in box:  
            label = tkinter.Label(frame, text=i)  
            label.pack()  
        # 更新Canvas的滚动区域  
        frame.update_idletasks()  
        canvas.config(scrollregion=canvas.bbox("all"))  
        def close():  
            root.destroy()  
        root.protocol("WM_DELETE_WINDOW", close)  
    except:  
        messagebox.showerror("错误","fail!!!")
```

> **注意**：这里使用的`messagebox.showerror()`函数需要导入`messagebox`模块，
> 导入命令： `from tkinter import messagebox`

代码执行过程中，我发现缺少点什么东西，没有时间显示感觉等待的过程枯燥乏味，那为何不给它添加一条进度条呢？浅浅的搜索补充一下缺乏的进度条知识点：

	进度条来自比tkinter更高级的ttk模块，需要从tkinter中进行导入。创建进度条命令类似于创建组件的命令。

因为进度条不管是否查询到结果都要执行，并且我在查询函数中使用了异常处理代码块，那刚刚好，我只需要给它添加一个`finally`，这样不管它是否查找到按钮信息都会启动进度条。Progressbar组件即进度条有两个特别的参数，分别是`progressbar对象['maximum']`和`progressbar对象['value']`，它俩的作用就好比使用前者确定一个容器的总容量，而后者用来更新目前这个容器的容量大小，当`value`的值从`0~maximum`时，进度条将会从空跑到满，可以很直观的看到进度，进度条程序如下：

```python
progress = ttk.Progressbar(root, orient="horizontal", length=300, mode="determinate")  
progress.place(x=100, y=275, width=300, height=20)  
progress["maximum"] = 60  # 这里我让进度条的容量为60
global time_progress  # 这里我创建一个累加器，用来更新value值
time_progress = 0  # 初始化累加器
def update_progress():  
    def update():  
        global time_progress  
        time_progress += 1  
        progress["value"] = time_progress  
        if time_progress < 60:  
            root.after(1000, update)  # 每隔1s重新调用一次，有效的控制了进度条的更新时间
        else:  
            progress.destroy()  
    update()  
threading.Thread(target=update_progress).start()  # 为进度条单独开一个线程，避免卡顿
```

好了，现在我所需的基本功能都可以实现了，看一下运行效果吧！

![[Pasted image 20250627181901.png]]

哈哈，在经过电脑一晚上的孤独奋战后，我成功完成老师的学习任务！！！

![[Pasted image 20250627182201.png]]

>[!tips] 后续补充
>感觉学习tkinter更不如去学习PyQt5/6效果更好！！！

