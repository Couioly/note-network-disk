## 1 什么是类
---
**类**（class）是描述一类事物的模板：
- 类中的变量叫做**成员变量**，表示事物的**属性**；
- 类中的方法叫做**成员方法**，表示事物的**行为**。

```java
public class Girl{
	String name;
	int height;
	double weight;
	
	// 每个Girl类对象都会的行为，即成员方法
	int calculateBMI(){  
double heightInMeter = height / 100.0;  
      return (int)(weight / (heightInMeter * heightInMeter));
}
```

## 2 什么是对象
---
**对象**（object）则是这根据**类**这个模板创建的具体实例：
- 创建类对象语法：`类型 变量名 = new 类型();`

```java
// 创建Girl类的实例对象
Girl girl1 = new Girl();  
// 给对象的属性赋值  
girl1.name = "小花";  
girl1.height = 168;  
girl1.weight = 45;  
System.out.println("小花名字：" + girl1.name);  
System.out.println("小花身高：" + girl1.height);  
System.out.println("小花体重：" + girl1.weight);  
// 调用对象的方法  
int bmi = girl1.calculateBMI();  
System.out.println("小花BMI：" + bmi);  
  
Girl girl2 = new Girl();  
girl2.name = "小王";  
girl2.height = 170;  
girl2.weight = 60;  
System.out.println("小王的名字：" + girl2.name);  
System.out.println("小王的身高：" + girl2.height);  
System.out.println("小王的体重：" + girl2.weight);  
int bmi2 = girl2.calculateBMI();  
System.out.println("小王的BMI：" + bmi2);
```

## 3 类和对象的内存结构
---
**内存结构**

- **基本类型**的变量，如`int num = 10;`，定义是将在内存中开辟4字节的空间，起名为num，将“10”存储在该内存中，即直接存储值，基本类型变量所属空间为**栈空间（stack）**；
- **对象（引用）类型**的变量，如`Girl girl = new Girl();`，通常存储在**堆（dump）** 空间中，表示在该空间中创建一个名为Girl的空间，而`Girl girl`将会在栈空间中创建一个名为girl的空间，该空间将存储Girl堆空间的**地址**。

>[!warning] 存储过程
>执行`girl.name = "小美";`语句
>首先在栈空间中找到girl变量，根据该变量存储的地址找到Girl在堆空间中的地址，然后在堆空间的Girl类对象的存储空间中找到name变量进行赋值。

![[Pasted image 20251013205624.png]]

当引用数据类型的一个变量赋值给另一个变量，这两个变量将产生关联，则修改另一个变量的值时，也会同时修改该变量的值。

>[!Error] 原因
>这是因为当引用数据类型的一个变量赋值给另一个变量时，将会把该变量存储的地址赋值给另一个变量，因此这两个变量将指向同一个地址堆空间，所以在修改任意一个时将会导致另一个变量也修改。

## 4 封装
---
```
编写程序实现员工工资计算功能，工资计算公式如下：

	员工工资 = 底薪 + 奖金 * 绩效系数

其中，绩效系数分为五级：
A：绩效系数为1.0
B：绩效系数为0.8
C：绩效系数为0.6
D：绩效系数为0.4
E：绩效系数为0
```

### 4.1 过程式编程

```java
public class SalayDemo {  
    public static void main(String[] args){  
        // 底薪  
        int baseSalary = 5000;  
        // 奖金  
        int bonus = 10000;  
        // 绩效等级  
        char grade = 'A';  
  
        // 计算薪资  
        int salary = calculateSalary(baseSalary,bonus,grade);  
        System.out.println("员工工资：" + salary);  
    }  
    public static int calculateSalary(int baseSalary,int bonus,char grade){  
        // 计算奖金系数  
        double rate = switch (grade){  
            case 'A' -> 1.0;  
            case 'B' -> 0.8;  
            case 'C' -> 0.6;  
            case 'D' -> 0.4;  
            default -> 0;  
        };  
        return (int)(baseSalary + bonus * rate);  
    }  
}
```

**过程式编程缺点：**

- 复用性差
- 可维护性低
- 程序复杂

### 4.2 封装

**封装（Encapsulation）**：是面向对象的核心特点之一，要求将**数据**和**操作这些数据的方法**捆绑在一起，作为一个整体。

1）将数据和操作数据的方法捆绑在一起，作为一个整体；

```java
public class Employee {  
    // 底薪  
    int baseSalary;  
    // 奖金  
    int bonus;  
  
    public int calculateSalary(char grade){  
        // 计算奖金系数  
        double rate = switch (grade){  
            case 'A' -> 1.0;  
            case 'B' -> 0.8;  
            case 'C' -> 0.6;  
            case 'D' -> 0.4;  
            default -> 0;  
        };  
        return (int)(baseSalary + bonus * rate);  
    }  
}
```

2）封装后可以新建类进行数据定义和操作。

```java
public class SalayDemo {  
    public static void main(String[] args){  
        Employee employee = new Employee();  
        employee.baseSalary = 5000;  
        employee.bonus = 10000;  
  
        System.out.println("员工工资：" + employee.calculateSalary('A'));  
    }  
}
```

### 4.3 Getter和Setter

若定义员工薪资时输入错误，则需要对员工的薪资进行校验，而这个校验应该在每次定义薪资时自动校验，因此应该是员工类的行为。

```java
// 在员工类中新建校验薪资行为
public void setBaseSalary(int baseSalary){  
    if(baseSalary < 0){  
        throw new IllegalArgumentException("底薪不能小于0"); // 抛出异常  
    }else this.baseSalary = baseSalary;  
}
```

>[!tips] this介绍
>`this.baseSalary = baseSalary;`中的`this`代表的是当前对象，访问的是当前对象的成员。

当设置了薪资校验行为后，则在后续的定义薪资的数据时也发生了变化：

```java
//原来的定义数据方式
employee.baseSalary = -5000;
// 定义薪资校验后的定义数据方式
employee.setBaseSalary(-5000);
```

>[!Question] 疑惑
>此时会发现在定义薪资校验行为后任然可以使用`employee.baseSalary`的方式进行数据的定义，这时只需在员工类的成员变量前添加`private`将变量设置为私有变量。

同理，若要获取成员变量的值时可以为成员变量设置`Getter`方法，如：

```java
public int getBaseSalary(){
	return this.baseSalary;
}
```

IDEA自带的Getter和Setter方法生成工具：

![[Pasted image 20251013221318.png]]

### 4.4 降低耦合

**耦合（Coupling）** 是指事物之间存在相互依赖、相互影响、相互制约的情况。在程序设计中是指一个类依赖于另一个类的程度。（即牵一发而动全身）

什么是耦合？

就上述例子而论，在计算员工薪资之前需要计算奖金系数，计算奖金系数将会调用`employee.calculateSalary('A');`实例方法，而该实例方法的方法体及方法体中所调用的方法内容为：

```java
public int calculateSalary(char grade){  
    // 计算奖金系数  
    double rate = calculateRate(grade);  
    return (int)(baseSalary + bonus * rate);  
}  
  
public double calculateRate(char grade){  
    return switch (grade){  
        case 'A' -> 1.0;  
        case 'B' -> 0.8;  
        case 'C' -> 0.6;  
        case 'D' -> 0.4;  
        default -> 0;  
    };  
}
```

目前程序执行一切正常，但是，倘若此时我们需要对`calculateSalary`方法进行升级如下：

```java
public int calculateSalary(char grade){  
    // 计算奖金系数  
    double rate = calculateRate(grade,false);  
    return (int)(baseSalary + bonus * rate);  
}  
  
public double calculateRate(char grade,boolean hasProfit){  
    if(!hasProfit){return 0;}  
    return switch (grade){  
        case 'A' -> 1.0;  
        case 'B' -> 0.8;  
        case 'C' -> 0.6;  
        case 'D' -> 0.4;  
        default -> 0;  
    };  
}
```

那么此时一开始调用该方法的`employee.calculateSalary('A');`语句将出现异常，这便是耦合带来的问题。

降低耦合的方法：
- 隐藏不必要的细节（在定义方法时使用`private`修饰符）

### 4.5 构造方法

在上述示例调用执行的过程中不难发现，该过程需要严格按照“先创建对象->再设置属性变量->调用实例方法”的顺序执行，代码指令如下：

```java
Employee employee = new Employee();  
employee.setBaseSalary(5000);  
employee.setBonus(10000);
int salary = employee.calculateSalary('C');
```

上述步骤缺一不可，为此，出现了一种更为方便的解决该复杂步骤的方式——**构造方法**！

>[!Error] 构造方法
>当程序中不存在构造方法时，将使用JVM的默认构造方法。即在`new Employee();`时后面的`Employee()`其实是在调用默认构造方法，默认构造方法中会对**成员属性进行默认初始化**，但是一旦自定义了构造方法，默认构造方法将会消失。

构造方法语法格式：

```java
class 类名{
	...
	/*
	*构造方法：
	*1. 没有返回值；
	*2. 方法名与类名完全一致
	*/
	public 类名([args,*]){
		...
	}
	...
}
```

以上述构造员工对象的示例为例：

```java
public Employee(int baseSalary, int bonus){  
    setBaseSalary(baseSalary);  
    setBonus(bonus);  
}
```

有了构造方法后便可以在创建员工对象的同时按照提示传入对应的构造方法的参数，即`Employee employee = new Employee(5000,10000);`命令，这样会将代码的耦合性降到最低。

>[!Question] 什么是封装？
>- 封装是面向对象的三大特征之一，简单来说就是把数据和操作数据的方法放到一起
>- 封装的目的是为了**降低耦合**，提高程序的**可维护性**、**可复用性**

>[!Question] 如何实现封装？
>- 把数据和操作数据的方法放到一个类中，作为类的**成员变量**和**成员方法**
>- 成员变量私有化，对外提供**Getter**和**Setter**方法操作成员变量
>- 对于必须初始化的成员变量，以**构造方法**来接收参数完成初始化
>- **隐藏**不必要的**细节**，之对外暴露必要的方法

## 5 继承
---
在程序设计中，**继承**是指让一个类继承另一个类的成员，从而提高代码的**复用性**。被继承的类叫做**父类**，继承的类就是**子类**。子类可以访问父类的**非私有成员或方法**。

Java中用 `extends` 关键字实现继承。例如：

```java
public class Product {  
    private String name;  
    private double price;  
  
    public String displayInfo() {  
        return "商品名称："+name+" 商品价格："+price;  
    }  
  
    public void setName(String name) {  
        this.name = name;  
    }  
  
    public void setPrice(double price) {  
        this.price = price;  
    }  
}
```

上述为一个最初定义的类（父类），然后让其他类（子类）继承它，如下：

```java
public class PhysicalProduct extends  Product{  
    private double weight;  
  
    public double getWeight() {  
        return weight;  
    }  
  
    public void setWeight(double weight) {  
        this.weight = weight;  
    }  
}
```

**继承的特点：**
1. java中只能单继承，也就是一个类只能有一个父类
2. java中可以多重继承，即子类继承的父类也继承着其他父类
3. java中有一个顶级父类，即 `Object`
4. 子类若要访问父类的成员方法或属性，可以使用 `super` 关键字
5. 当子类继承父类时

>[!warning] 
>任何类默认继承Object类（直接或间接继承）

>[!Error] 错题本
>1. `public`关键字是不可用来控制对类成员的访问
>2. `int x=010,y=10,z=0x10;`赋值的结果依次为：8、10、16
>3. 在Java中一个类中可以定义多个构造方法

## 6 抽象
---
常使用`abstract`定义抽象方法或抽象类，例如下列代码定义一个抽象类，类中包含一个抽象方法：

```java
abstract class AbstractDemo{  
    private String name;  
    private int age;  
    public AbstractDemo(String name, int age){  
        this.name = name;  
        this.age = age;  
    }  
    public void setName(String name){  
        this.name = name;  
    }  
    public String getName(){return name;}  
    public void setAge(int age){  
        this.age = age;  
    }  
    public int getAge(){return age;}  
    abstract void info();  
}  
class Demo extends AbstractDemo{  
    public static void main(String[] args) {  
        Demo demo = new Demo("Cony",19);  
        demo.info();  
    }  
    public Demo(String name, int age){  
        super(name, age);  
    }  
    @Override  
    void info() {  
        System.out.println("hello world");  
        System.out.println("name:"+super.getName()+" age:"+super.getAge());  
    }  
}
```

>[!warning] 注意事项
>1. 抽象类无法创建对象，但可以被继承；
>2. 继承的子类必须对父类的抽象方法进行重写



## 7 多态
---
首先定义一个父类和一个该父类的子类：

```java
class Person{
	String name;
	int age;
	public Person(String name,int age){
		this.name = name;
		this.age = age;
	}
}

class Student extends Person{
	String grade;
	String classroom;
	public Student(String name,int age,String grade,String classroom){
		super(name,age);
		this.grade = grade;
		this.classroom = classroom;
	}
	public void show(){  
    System.out.println("姓名："+name+" 年龄："+age+" 班级："+grade+" 教室："+classroom);  
}
}
```

### 7.1 向上转型

假设现在需要创建一个Student对象，可以直接使用下面的语法（无法使用Student的方法）：

```java
Person person = new Student("张三",18,"大一","1-1")
```

### 7.2 向下转型

若在上述的情况下使用Student对象的属性或方法，可以用到向下转型的方式：

```java
// 向上转型的知识点
Person person = new Student("张三",18,"大一","1-1")
// 向下转型的知识点
Student student = (Student)person;
student.show();
```

## 8 接口
---
>[!Error] 错题本
>1. 实现接口使用 `implements` 关键字
>2. 接口中包含静态常量和抽象方法
>3. 接口继承成可以继承多个

接口中的方法默认都是 `public abstract` 修饰的，而属性默认是 `public abstract final` 修饰的。

定义接口的关键字 `interface`：

```java
interface Showable{  
    void show();  
}
class Product implements Showable{
	String name;
	double price;
	public Product(String name,double price){
		this.name = name;
		this.price = price;
	}
	public void show(){
		System.out.println(name+":"+price);
	}
}
```

