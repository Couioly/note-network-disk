在应用程序中，将**多个程序块同时运行**的现象称为**并发执行**。**多线程**是指一个应用程序中有**多条并发执行**的线索，每条线索被称为一个**线程**。它们交替执行，彼此间可以进行通信。

## 1 线程与进程

一台计算机可以同时执行多个程序，而这**每个运行中的程序**都是**一个进程**，每个进程都拥有相对**独立的执行环境**。进程时程序的实例，时操作系统动态执行的**基本单元**。

**进程**的实质是程序在多到程序系统中的**一次执行过程**，但进程中的**实际运作单位是线程**。线程是操作系统能够进行运算调度的最小单位，它被包含在进程之中。**一个进程中至少存在一个线程**，每一个线程都是进程中一个单一顺序的控制流。

**多线程程序**是指程序中实现多段程序代码**交替运行**的效果。创建线程的方式有以下3种：

- 继承`Thread`类
- 实现`Runnable`接口
- 基于`Callable`接口和`Future`类

**接下来实现判断指定列表中年份的平闰年**

#### 1.1 继承 Thread 类创建

编写多线程程序，需要在程序中创建并启动**除主线程之外**的**其他线程**，Java中使用`Thread`类来代表线程，所有的**线程对象**都必须是`Thread`类或其子类的实例。`Thread`类用于**分配线程对象的构造方法**：

| 方法声明                                  | 说明                                   |
| ------------------------------------- | ------------------------------------ |
| `Thread()`                            | 创建一个线程对象                             |
| `Thread(String name)`                 | 创建一个名称为name的线程对象                     |
| `Thread(Runnable target)`             | 根据任务对象target创建一个线程对象                 |
| `Thread(Runnable target,String name)` | 根据任务对象target创建一个线程对象，并指定线程对象的名称为name |
>[!warning] 注意
>若未指定线程名字，程序会自动为线程分配格式为 `Thread-n` 的名称，n为非负整数的数字。

Thread类提供的常用于**操作线程**的方法如下：

| 方法声明                             | 说明                   |
| -------------------------------- | -------------------- |
| `String getName()`               | 获取当前线程的名称            |
| `void setName(String name)`      | 将当前线程的名称更改为参数name    |
| `void start()`                   | 启动一个新线程              |
| `void run()`                     | 线程的执行方法，是线程执行的主体     |
| `static void sleep(long millis)` | 使当前正在执行的线程休眠millis毫秒 |
>[!warning] 注意事项
>1. `start()`方法用于**启动一个新线程**，但是该方法本身**并不是执行线程代码**的方法。`start()`方法只能告诉JVM该线程已准备好被执行，并由JVM来负责调度和执行；
>2. 当线程获得了CPU时间片后，就会调用该线程的`run()`方法，该方法是线程的**执行方法**，其中包含线程的**主要执行逻辑**；
>3. 若直接调用`run()`方法，则该方法**并不会启动线程**，只是在**当前线程**中执行了`run()`方法中的代码而已。

**通过Thread类创建线程步骤**：

1. 首先定义通用的闰年判断规则：
```java
public class LeapYearUtil {  
    /**  
     * 判断单个年份是否为闰年  
     * 规则：能被4整除但不能被100整除，或能被400整除  
     */  
    public static boolean isLeapYear(int year) {  
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);  
    }  
}
```

2. 定义`Thread`类的子类，并重写Thread类的`run()`方法，在`run()`方法中定义线程要执行的任务；

```java
// 单个年份的闰年判断线程  
class LeapYearThread extends Thread {  
    private int year;  
  
    public LeapYearThread(int year) {  
        this.year = year;  
    }  
  
    @Override  
    public void run() {  
        boolean result = LeapYearUtil.isLeapYear(year);  
        System.out.printf("线程[%s]：年份%d %s闰年%n",  
                Thread.currentThread().getName(), year, result ? "是" : "不是");  
    }  
}
```

>[!bug] 异常处理
>`sleep()`可能导致`InterruptedException`异常！

3. 创建Thread子类的实例，即创建**线程对象**；
4. 调用线程对象的`start()`的方法启动线程。

```java
// 测试类  
public class LeapYearThreadDemo {  
    public static void main(String[] args) {  
        // 待判断的年份数组  
        int[] years = {2000, 2020, 2024, 1900, 2025};  
  
        // 为每个年份创建线程并启动  
        for (int year : years) {  
            new LeapYearThread(year).start();  
        }  
    }  
}
```

运行结果：

```
线程[Thread-0]：年份2000 是闰年
线程[Thread-1]：年份2020 是闰年
线程[Thread-4]：年份2025 不是闰年
线程[Thread-3]：年份1900 不是闰年
线程[Thread-2]：年份2024 是闰年
```

#### 1.2 实现 Runnable 接口创建

Java是**单继承**，因此若继承其他父类时将无法通过继承 `Thread` 类进行创建线程，因此，可以借助`Thread`类提供的`Thread(Runnable target)` 或 `Thread(Runnable target, String name)`构造方法来创建线程，其中`Runnable`接口的实例代表一个需要执行的具体任务，通常被称为**任务对象**，`Runnable`接口只包含一个`run()`方法，用于**定义线程的执行代码**。

**通过实现Runnable接口创建多线程的步骤**：

1. 首先定义通用的闰年判断规则：

```java
public class LeapYearUtil {  
    /**  
     * 判断单个年份是否为闰年  
     * 规则：能被4整除但不能被100整除，或能被400整除  
     */  
    public static boolean isLeapYear(int year) {  
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);  
    }  
}
```

2. 定义`Runnable`接口的实现类，并重写该接口`run()`方法；

```java
// 闰年判断任务（实现Runnable）  
class LeapYearTask implements Runnable {  
    private int year;  
  
    public LeapYearTask(int year) {  
        this.year = year;  
    }  
  
    @Override  
    public void run() {  
        boolean result = LeapYearUtil.isLeapYear(year);  
        System.out.printf("线程[%s]：年份%d %s闰年%n",  
                Thread.currentThread().getName(), year, result ? "是" : "不是");  
    }  
}
```

3. 创建`Runnable`实现类的实例，并将实例作为`Thread`的任务对象**创建Thread对象**；
4. 调用线程对象的`start()`方法启动线程。

```java
// 测试类  
public class LeapYearRunnableDemo {  
    public static void main(String[] args) {  
        int[] years = {2000, 2020, 2024, 1900, 2025};  
  
        // 为每个任务分配线程  
        for (int year : years) {  
            Thread thread = new Thread(new LeapYearTask(year));  
            thread.start();  
        }  
    }  
}
```

运行结果：

```
线程[Thread-0]：年份2000 是闰年
线程[Thread-4]：年份2025 不是闰年
线程[Thread-2]：年份2024 是闰年
线程[Thread-3]：年份1900 不是闰年
线程[Thread-1]：年份2020 是闰年
```

#### 1.3 实现 Callable 接口创建

通过实现`Runnable`接口创建线程时，将重写的`run()`方法包装成**线程执行体**，由于`run()`方法**没有返回值**，因此如果线程执行结果需要返回值时，实现`Runnable`接口的方式将不适用。此时，可使用`Callable`接口，该接口的`call()`方法可以作为线程的执行体，并且**有返回值**。

>[!warning] 提示
>`Callable`对象不能直接作为`Thread`构造方法的`target`参数，需要借助`FutureTask`类创建对应的参数对象，`FutureTask`类提供的构造方法可以传入一个`Callable`对象对其封装起来，作为创建`Thread`对象时的`target`参数值。当线程执行时，`FutureTask`内部会执行`Callable`对象的`call()`方法，并将结果存储在`FutureTask`中。

`Future`接口管理线程的5个方法：

| 方法声明                                            | 功能描述                                                                                 |
| ----------------------------------------------- | ------------------------------------------------------------------------------------ |
| `boolean cancel(boolean mayInterruptIfRunning)` | 用于尝试取消任务，参数`mayInterruptIfRunning`表示**是否允许取消正在执行却没有执行完毕的任务**，如果设置true，则表示可以取消正在执行的任务 |
| `boolean isCancelled()`                         | 判断任务是否被取消，如果被取消返回true，否则返回false                                                      |
| `boolean isDone()`                              | 判断任务是否已经完成，如果任务完成返回true，否则返回false                                                    |
| `V get()`                                       | 用于获取执行结果，这个方法**会发生阻塞**，一直等到任务行完毕才返回执行结果                                              |
| `V get(long timeout, TimeUnit unit)`            | 用于在指定时间内获取执行结果，如果在指定时间内无法获取到结果则抛出异常                                                  |
**基于Callable和FutureTask创建线程的步骤：**

1. 首先定义通用的闰年判断规则：

```java
public class LeapYearUtil {  
    /**  
     * 判断单个年份是否为闰年  
     * 规则：能被4整除但不能被100整除，或能被400整除  
     */  
    public static boolean isLeapYear(int year) {  
        return (year % 4 == 0 && year % 100 != 0) || (year % 400 == 0);  
    }  
}
```

2. 创建`Callable`接口的实现类；

```java
import java.util.concurrent.Callable;  
  
// 带返回值的闰年判断任务  
class LeapYearCallable implements Callable<String> {  
    private int year;  
  
    public LeapYearCallable(int year) {  
        this.year = year;  
    }  
  
    @Override  
    public String call() throws Exception {  
        boolean result = LeapYearUtil.isLeapYear(year);  
        // 返回任务结果（自定义格式）  
        return String.format("年份【%d】：%s闰年", year, result ? "是" : "不是");  
    }  
}
```

3. 创建包装了`Callable`对象的`FutureTask`类；
4. 使用`FutureTask`对象作为Thread对象的target参数并启动线程。

```java
import java.util.concurrent.FutureTask;

public class LeapYearFutureTaskDemo {  
    public static void main(String[] args) throws Exception {  
        // 待判断的年份数组  
        int[] years = {2000, 2020, 2024, 1900, 2025};  
  
        for (int year : years) {  
            // 1. 创建Callable任务对象  
            Callable<String> callable = new LeapYearCallable(year);  
  
            // 2. 用FutureTask包装Callable（FutureTask实现了RunnableFuture接口）  
            FutureTask<String> futureTask = new FutureTask<>(callable);  
  
            // 3. 创建线程并启动（FutureTask作为Runnable传入Thread）  
            Thread thread = new Thread(futureTask, "闰年判断线程-" + year);  
            thread.start();  
  
            // 4. 获取任务结果（get()会阻塞直到任务完成）  
            String result = futureTask.get();  
            System.out.println("线程[" + thread.getName() + "]结果：" + result);  
        }  
    }  
}
```

运行结果：

```
线程[闰年判断线程-2000]结果：年份【2000】：是闰年
线程[闰年判断线程-2020]结果：年份【2020】：是闰年
线程[闰年判断线程-2024]结果：年份【2024】：是闰年
线程[闰年判断线程-1900]结果：年份【1900】：不是闰年
线程[闰年判断线程-2025]结果：年份【2025】：不是闰年
```

| 创建方式                  | 优点                                                             | 缺点                                                                       |
| --------------------- | -------------------------------------------------------------- | ------------------------------------------------------------------------ |
| 继承Thread类             | 编码相对简单                                                         | 1. 存在单继承的局限性，不便于扩展<br/>2. 不能返回线程执行的结果<br/>3. 每个线程的任务和线程本身是耦合的，无法将任务和线程分离 |
| 实现Runnable接口          | 1. 可以继续继承类和实现接口，扩展性强<br/>2. 任务和线程分离，可以实现多个线程共享同一个任务            | 编码相对复杂，不能返回线程执行的结果                                                       |
| 基于Callable和FutureTask | 1. 线程任务类只是实现接口，可以继续继承类和实现接口，扩展性强。<br/>2. 可以在线程执行完毕后去获取线程执行的结果。 | 编码相对复杂                                                                   |
## 2 线程生命周期

线程生命周期的**六种基本状态**：

- 新建状态
- 可运行状态
- 阻塞状态
- 无限等待状态
- 计时等待状态
- 被终止状态

#### 2.1 新建状态 

创建一个线程对象，但还没调用**start()方法**启动线程，该线程就处于**新建状态**。此时，新建状态的线程和其他声明但未赋值的Java对象类似，JVM**仅为其分配了内存**，并没有表现出任何**线程的动态特征**。 

#### 2.2 可运行状态 

当线程对象调用了**start()方法**后就进入**可运行状态**，也称为**就绪状态**。处于可运行状态的线程位于**线程队列**中，此时它只是具备了运行的**条件**，要获得**CPU的使用权**并开始运行，还需要等待系统的**调度**。 

#### 2.3 阻塞状态 

如果处于**可运行状态**的线程获得了**CPU的使用权**，并开始执行**run()方法**中的线程执行体，则线程**处于运行状态**。 一个线程启动后，它可能不会一直处于运行状态，当一个线程试图获取一个**对象锁**，而该对象锁被**其他的线程**持有时，则该线程进入**阻塞状态**。当其他线程**释放对象锁**，该线程获得对象锁时，该线程将重新变成**可运行状态**。 

#### 2.4 无限等待状态 

一个线程在等待另一个线程执行一个**唤醒**动作时，该线程进入**无限等待状态**。线程进入这个状态后是不能**自动唤醒**的，必须等待另一个线程**调用notify()方法或者notifyAll()方法**才能够唤醒。 

#### 2.5 计时等待状态 

计时等待状态是指线程在调用了具有指定等待时间的方法后而进入的状态，这些方法包括**Thread类的sleep()方法和join()方法、Object类的wait()方法、LockSupport类的parkNanos()方法、LockSupport.parkUntil()** 等。 当线程调用这些方法并指定了等待时间，它就会进入**计时等待状态**，这一状态将一直保持到**超时**或者接收到**唤醒通知**。

#### 2.6被终止状态 

被终止状态是终止运行的线程的状态。线程因为run()方法正常退出，或者线程抛出一个**未捕获的异常(Exception)或者错误(Error)** 时终止了**run()方法**而结束执行。

在多线程程序中，CPU会在多个线程之间**切换执行**，因此，线程的状态会在**可运行**和**阻塞**之间切换，通过一些操作也可以使线程在**不同状态之间转换**。

![](./images/file-20251124215955204.png)

## 3 线程同步

