
### 指针与函数

**指针**：存储地址的变量
**间接引用操作符**：`*` 返回指针变量指向地址的值

**题目：设计一个函数，传入两个int参数，并交换这两个参数的值**

```c
void swap(int a, int b) {  
    int temp;  
    temp = a;  
    a = b;  
    b = temp;  
    printf("swap: a = %d, b = %d\n", a, b);  
}
void main() {  
    int i = 5;  
    int j = 10;  
    swap(i,j);  
    printf("basic: i = %d, j = %d\n",i,j);  
}
```

当外部调用该函数时，该函数只会在内部进行参数交换，不会影响到全局变量。所以调用结果如下：

```
swap: a = 10, b = 5
basic: i = 5, j = 10
```

>[!Question] 如何结合指针对全局变量进行修改？

```c
void swap(int *a, int *b) {  
    int temp = *a;  
    *a = *b;  
    *b = temp;  
    printf("swap: a = %d, b = %d\n", *a, *b);  
}  
  
void main() {  
    int i = 5;  
    int j = 10;  
    swap(&i,&j);  
    printf("basic: a = %d, b = %d\n",i,j);  
}
```

当使用指针作为形参时传参必须传入地址，借助指针指向地址，可以对指定的内容进行修改，运行结果如下：

```
swap: a = 10, b = 5
basic: i = 10, j = 5
```

### 指针与数组

在C语言中，通过数组下标能完成的操作都可以通过指针完成（指针编译的程序执行速度快）

数组可以直接赋值给指针变量，指针变量将存储**数组的首地址**，如下面示例：

```c
void main() {  
    int a[] = {13,22,66,44,88};  
    int *p = a;  
    printf("%p\n",a);  
    printf("%p\n",p);  
    printf("%d\n",*p);  
}
```

运行结果如下：

```
000000b15cdffab0
000000b15cdffab0
13
```

给指针加上一个整数，实际上加的是这个整数和指针数据类型对应字节数的乘积。即：`p = p + 1`--> `p = p + 1 * 4` （因为整数`int`为四个字节，所以`*4`），如下示例：

```c
void main() {  
    int a[] = {13,22,66,44,88};  
    int *p = a;  
    for (int i = 0; i < sizeof(a) / sizeof(a[0]); i++) {  
        printf("%d\t",a[i]);  
    }
    
    printf("\n");
    
    for (int i = 0; i < sizeof(a) / sizeof(a[0]); i++) {  
        printf("%d\t",*(p+i));  
    }  
}
```

运行结果如下：

```
13      22      66      44      88
13      22      66      44      88
```

各数据类型字节数表（区分32位和64位）

![[Pasted image 20251104214044.png]]

### 结构体的声明

结构体是一个或多个变量的集合，这些变量可以是不同的类型，即**自定义数据类型**。声明语法：

```c
struct 结构体名{
	数据类型 变量名;
	数据类型 变量名;
	...
};
```

**示例**：

```c
struct point {
	int x;
	int y;
};
```

### 结构体的初始化与调用

```c
struct 结构体名 变量名;
// 示例
struct point p;
```

如何给自定义类型变量赋值？

```c
变量名.结构体内部变量名 = 值;
// 示例
struct point p;
p.x = 10;
p.y = 15;
```

### 结构体与指针

在一些场景中，若传递给函数的结构体很大，使用指针方式的效率通常更高。例如：pp指向一个point结构体

```c
struct point *pp;
// 为pp所指向的结构体中的属性赋值
*(pp).x = 10;
*(pp).y = 15;
// 为了方便使用，C语言提供了一种简便的写法
pp->x = 10;
pp->y = 15;
```

### 类型定义

```c
typedef 数据类型 别名;
// 示例
typedef int zx;
zx a = 15;
zx b = 10;
```

`typedef` 可以解决结构体每次使用都带 `struct` 前缀的烦恼，定义方式如下：

```c
typedef struct 结构体名{
	数据类型 变量名;
	数据类型 变量名;
	...
}别名;
// 示例
typedef struct point{
	int x;
	int y;
}po;
```

```c
typedef struct{
	数据类型 变量名;
	数据类型 变量名;
	...
}别名;
// 示例
typedef struct{
	int x;
	int y;
}po;
```

### 内存分类

C程序编译后，会以三种形式使用内存：

- **静态/全局内存**：静态声明的变量和全局变量使用这部分内存，这些变量在程序开始运行时分配，直到程序终才消失
- **自动内存（栈内存）**：函数内部声明的变量使用这部分内存，在函数被调用时才创建（内存不可控，它是自动的）
- **动态内存（堆内存）**：根据需求编写代码动态分配内存，可以编写代码释放，内存中的内容直接释放才消失（内存可控）


### 动态内存分配

1. 使用 `malloc` (memory allocate) 函数分配内存，`void* malloc(size_t)`，其中 `void*` 是通用数据类型指针，传入需开辟的空间大小，返回该类型空间的地址
	- 开辟成功：会返回从堆内存上分配的内存指针
	- 开辟失败：会返回空指针
2. 使用分配的内存
3. 使用 `free` 函数释放内存

**动态内存分配示例——基本数据类型**

```c
#include <stdio.h>  
#include <stdlib.h>  
void main() {  
    int *p = (int *) malloc(sizeof(int));  
    *p = 10;  
    printf("%d\n", *p);  
    free(p);  
}
```

>[!BUG] 切记！！！
>当分配完后一定要释放空间，它不会自动释放！

**动态内存分配示例——字符串**

```c
#include <stdio.h>  
#include <stdlib.h>  
#include <string.h>  
void main() {  
    char *s = (char *) malloc(10);  
    strcpy(s, "hello");  
    printf("%s\n", s);  
    free(s);  
}
```

**动态内存分配示例——数组**

```c
#include <stdio.h>  
#include <stdlib.h>  
void main() {  
    int *arr = (int*)malloc(5 * sizeof(int));  
    for (int i = 0; i < 5; i++) {arr[i]=0;}  
    for (int i = 0; i < 5; i++) {printf("%d ", arr[i]);}  
    free(arr);  
}
```

**动态内存分配示例——结构体**

```c
#include <stdio.h>  
#include <stdlib.h>  
typedef struct {  
    int x;  
    int y;  
}po;  
void main() {  
    po *p;  
    p = (po*)malloc(sizeof(po));  
    p->x = 5;  
    p->y = 10;  
    printf("%d\n", p->x);  
    printf("%d\n", p->y);  
    free(p);  
}
```

