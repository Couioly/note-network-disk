
>[!tips] 学习目标
>1. 掌握线性表的概念；
>2. 掌握顺序表的概念，了解其基本操作的实现方法；
>3. 掌握顺序表的增删的思想和实现方法，重点掌握其时间复杂度；
>4. 掌握栈和顺序栈的概念和特点，掌握其入栈和出栈的思想及实现方法；
>5. 掌握队列和顺序队列的概念及特点，掌握顺序队列的进队和出队的思想及实现方法；
>6. 掌握循环队列的概念和特点，掌握循环队列的进队和出队的思想及实现方法，掌握循环队列空和满的判断条件，掌握各操作的时间复杂度；
>7. 运用栈或队列求解问题。

## 1 线性结构
---
### 1.1 线性结构的定义

若结构是非空有限集，则有且仅有一个开始结点和一个终端结点，并且所有结点都最多只有一个直接前驱和一个直接后继。

线性结构的表达式：（a₁,a₂,a₃,...,aₙ）

### 1.2 线性结构及线性表

线性结构的特点：
- **只有一个首结点和尾结点**；
- **除首尾结点外，其他结点只有一个直接前驱和一个直接后继**。

>线性结构包括：**线性表**、堆栈、队列、字符串、数组等等。

线性表在计算机的存储分为：
- **顺序存储**
- **链式存储**

## 2 顺序表
---
线性表采用**顺序存储的方式存储**就称为**顺序表**，又称为**顺序存储结构**或**顺序映像**。

**顺序存储定义**：把逻辑上相邻的数据元素存储在物理上相邻的存储单元中的存储结构。简言之，逻辑上相邻，物理上也相邻。

**顺序存储方法**：用**一组地址连续**的存储单元依次存储线性表的元素，可通过 **数组V[n]** 来实现。

<font color=red>顺序表的特点：随机存取、地址连续、类型相同、依次存放</font>

### 2.1 顺序表的类型定义

```c
/*********************************/
/* 顺序表的头文件，文件名:sequlist.h */
/*********************************/
#define MAXSIZE 100
typedef int datatype;
typedef struct {
    datatype a[MAXSIZE];
    int size;
}sequence_list;
```

### 2.2 顺序表的重要基本操作
---
#### 初始化——置空表

```c
/*********************************/
/* 函数功能:顺序表的初始化——置空表    */
/* 函数参数:sequence_list类型的指针 */
/* 函数返回值:无                   */
/* 文件名:sequlist.c,函数名:init() */
/*********************************/
void init(sequence_list *slt) {  
    slt->size = 0;  
}
```

>[!tips] 引用类型作形参的三点说明
>1. 传递引用给函数与传递指针的效果是**一样**的，**形参变化实参也发生变化**；
>2. 引用类型作为形参，内存中并没有产生实参的副本，它**直接对实参操作**；因此，当**参数传递的数据量较大**时，用引用比用一般变量传递参数的时间和空间效率都好；
>3. 指针参数虽然也能够达到使用引用的效果，但是在被调函数中需重复使用`* 指针变量`的形式进行运算，这易产生错误且程序阅读性差；且在主调函数的调用点处，必须用**变量的地址作为实参**。

>[!bug] 错误示范
>```c
>void init(sequence_list slt) {  
>   slt.size = 0;  
>}
>```
>
>切记此处不能使用上述语法进行置空表操作，它采用**值传递**，函数内部的`slt`是实参的**副本**，对`slt.size = 0`的修改仅作用于这个副本，**实参的`size`不会被改变**，初始化操作是 **“无效的”**。

>[!warning] C语言的动态分配函数（**stdlib.h**）
>- `malloc(m)`：开辟 m 字节长度的地址空间，并返回这段空间的首地址；
>- `sizeof(x)`：计算变量 x 的长度；
>- `free(p)`：释放指针 p 所指变量的存储空间，即彻底删除一个变量。

#### 在顺序表尾部进行插入操作

```c
/***********************************/
/* 函数功能:在顺序表尾部进行插入操作     */
/* 函数参数:sequence_list类型的指针   */
/*         datatype型变量x          */
/* 函数返回值:无                     */
/* 文件名:sequlist.c,函数名:append() */
/***********************************/
void append(sequence_list *slt, datatype x) {  
    if (slt->size == MAXSIZE) { // 判断顺序表是否已满  
        printf("sequence_list is full!\n");exit(1);  
    }  
    slt->a[slt->size] = x; // 向实际存储元素的尾部进行插入  
    slt->size++; // 实际长度增加1  
}
```

#### 输出顺序表的各节点值

```c
/************************************/
/* 函数功能:输出顺序表的各节点值         */
/* 函数参数:sequence_list类型变量      */
/* 函数返回值:无                      */
/* 文件名:sequlist.c,函数名:display() */
/************************************/
void display(sequence_list slt) { // 只进行查询操作可以使用值传递  
    if (!slt.size) printf("empty sequence_list!\n");  
    else  
    for (int i = 0; i < slt.size; i++) printf("%5d", slt.a[i]);  
}
```

#### 判断顺序表是否为空

```c
/**************************************/
/* 函数功能:判断顺序表是否为空             */
/* 函数参数:sequence_list类型变量        */
/* 函数返回值:int类型.1表示空,0表示非空    */
/* 文件名:sequlist.c,函数名:empty()     */
/**************************************/
int empty(sequence_list slt) {  
    return slt.size == 0 ? 1 : 0;  
}
```

#### 查找顺序表中值为x的节点位置

```c
/***********************************************/
/* 函数功能:查找顺序表中值为x的节点位置              */
/* 函数参数:sequence_list类型变量,datatype类型变量 */
/* 函数返回值:int类型.返回x的位置值,-1表示未找到     */
/* 文件名:sequlist.c，函数名:find()              */
/******************************************* **/
int find(sequence_list slt, datatype x) {  
    int i = 0;  
    while (i < slt.size && slt.a[i] != x) i++;  
    return i < slt.size ? i : -1;  
}
```

>[!warning] 时间复杂度
>根据内容查位置 --> 顺序查找O(n)

#### 取得顺序表中第i个节点的值

```c
/***********************************************/
/* 函数功能:取得顺序表中第i个节点的值                */
/* 函数参数:sequence_list类型变量,int类型变量      */
/* 函数返回值:datatype类型.返回第i个节点的值        */
/* 文件名:sequlist.c，函数名:get()               */
/******************************************* **/
datatype get(sequence_list slt, int i) {  
    if (i < 0 || i >= slt.size) {  
        printf("No i value was found!\n");  
        exit(1);  
    } else return slt.a[i];  
}
```

>[!warning] 时间复杂度
>根据位置查内容 --> 随机存取O(1)

#### 顺序表position位置插入x节点

![[Pasted image 20251008181038.png]]

>[!warning] 算法步骤
>1. 判断顺序表的**存储空间是否已满**；
>2. 判断**插入位置i是否合法**；
>3. 将第n至第i位的元素依次**向后移动一个位置**，空出第i个位置；
>4. 将要插入的新元素**e放入第i个位置**；
>5. **表长加1**，插入成功返回OK。

**在线性表中第i个数据元素之前插入数据元素x**

```c
/********************************************/
/* 函数功能:在顺序表的position位置插入值为x的节点  */
/* 函数参数:指向sequence_list类型的指针         */
/*         datatype型变量x,int型变量position  */
/* 函数返回值:空                              */
/* 文件名:sequlist.c,函数名:insert()          */
/********************************************/
void insert(sequence_list *slt, datatype x, int position) {  
    if (slt->size == MAXSIZE) {  
        printf("sequence_list is full!\n");  
        exit(1);  
    }  
    if (position < 0 || position > slt->size) {  
        printf("position is out of bounds!\n");  
        exit(1);  
    }  
    for (int i = slt->size; i > position; i--) slt->a[i] = slt->a[i - 1];  
    slt->a[position] = x;  
    slt->size++;  
}
```

>[!warning] 时间复杂度
>该算法中所花费的时间主要在元素后移操作上，在第i个位置上插入一个新的元素，需要移动n-i个元素。在一个长度为n的顺序表中插入一个元素平均需要移动表中的一半元素，平均移动次数为：
>$\sum_{i=0}^{n} p_i (n - i) = \sum_{i=0}^{n} \frac{1}{n + 1} (n - i) = \frac{1}{n + 1} \times \frac{n(n + 1)}{2} = \frac{n}{2}$
>
>因此，该算法的时间复杂度为**O(n)**。

#### 删除顺序表position位置的节点

```c
/********************************************/
/* 函数功能:删除顺序表中第position位置的节点      */
/* 函数参数:指向sequence_list类型的指针         */
/*         int型变量position                 */
/* 函数返回值:空                              */
/* 文件名:sequlist.c,函数名:dele()            */
/********************************************/
void dele(sequence_list *slt, int position) {  
    if (slt->size == 0) {  
        printf("empty sequence_list!\n");  
        exit(1);  
    }  
    if (position < 0 || position > slt->size) {  
        printf("position is out of bounds!\n");  
        exit(1);  
    }  
    for (int i = position; i < slt->size - 1; i++) slt->a[i] = slt->a[i + 1];  
    slt->size--;  
}
```

>[!warning] 时间复杂度
>删除操作于插入操作一样，区别在于所花费的时间主要在元素前移操作上，若要删除第i个元素，则需要移动n-i-1个元素。在一个长度为n的顺序表中删除一个元素平均需要移动表中大约一半的元素，平均移动次数为：
>$\sum_{i=0}^{n-1} q_i (n - i - 1) = \sum_{i=0}^{n-1} \frac{1}{n} (n - i - 1) = \frac{1}{n} \times \frac{n(n - 1)}{2} = \frac{n - 1}{2}$
>
>因此，该算法的时间复杂度为**O(n)**。

>[!Error] 空间复杂度
>顺序表未占用辅助空间，因此空间复杂度S(n)=O(1)

### 2.3 顺序表的优缺点

#### 优点

- **存储密度大**（结点本身所占存储量/结点结构所占存储量）
- 可以**随机存取**表中任一元素

#### 缺点

- 在插入、删除某一元素时，需要移动大量元素
- 浪费存储空间
- 属于静态存储形式，数据元素的个数不能自由扩充

>[!tips] 引入
>为了克服上述的缺点，我们将后续引入**链表**

## 3 栈
---
### 3.1 栈的基本概念及描述

**定义**：只能在**表的一端**（栈顶）进行插入和删除运算的**线性表**。栈的插入和删除操作称为**出栈**或**入栈**。
**逻辑结构**：一对一（与线性表相同）
**存储结构**：用**顺序栈**或**链栈**存储均可，顺序栈更常见。
**运算规则**：只能在**栈顶**运算，且访问结点时依照<font color=red>先进后出</font> **(FILO)** 的原则。
**实现方式**：
- 出/入栈
- 读栈顶元素值
- 建栈
- 判断栈满/空

![[d59d43342c6cca9684ced579465ef3cd.jpg]]

**栈的存储方式**：
- 顺序存储（顺序栈）
- 链式存储（链式栈）

**顺序栈**是特殊的顺序表，它的插入和删除操作规定在顺序表的同一端进行，所以顺序栈可以使用**一维数组**实现。

### 3.2 顺序栈的实现

```c
/************************/
/* 栈（顺序存储）的头文件   */
/* 文件名:seqstack.h     */
/************************/
#define MAXSIZE 100  
typedef int datatype;  
typedef struct{  
    datatype a[MAXSIZE];  
    int top;  
}sequence_stack;
```

### 3.3 栈的重要基本操作

#### 顺序栈初始化

```c
/**************************************/  
/* 函数功能:栈(顺序存储)初始化            */
/* 函数参数:sequence_stack类型的指针     */
/* 函数返回值：无                       */
/* 文件名:seqstack.c,函数名:init()     */  
/*************************************/  
void init(sequence_stack *st){  
    st->top = 0;  
}
```

#### 判断顺序栈是否为空

```c
/**************************************/  
/* 函数功能:判断栈(顺序存储)是否为空       */
/* 函数参数:sequence_stack类型的变量st   */
/* 函数返回值:int类型。1表示空,0表示非空   */
/* 文件名:seqstack.c,函数名:empty()     */  
/**************************************/
int empty(sequence_stack st){
	return (st.top ? 0 : 1);
}
```

#### 读取顺序栈顶节点值

```c
/**************************************/  
/* 函数功能:读取栈顶(顺序存储)节点值       */
/* 函数参数:sequence_stack类型变量st    */
/* 函数返回值:datatype类型。返回栈顶节点值 */
/* 文件名:seqstack.c,函数名:read()      */  
/**************************************/
datatype read(sequence_stack st){
	if(empty(st)){
		printf("sequence_stack is empty!");
		exit(1);
	}
	return st.a[st.top-1];
}
```

#### 顺序栈的插入操作

```c
/**************************************/  
/* 函数功能:栈(顺序存储)的插入操作         */
/* 函数参数:sequence_stack类型的指针     */
/*         datatype类型变量x           */
/* 函数返回值:无                        */
/* 文件名:seqstack.c,函数名:push()      */  
/**************************************/
void push(sequence_stack *st,daatype x){
	if (st->top == MAXSIZE){
		printf("The sequence stack is full!");
		exit(1);
	}
	st->a[st->top] = x;
	st->top++;
}
```

#### 顺序栈的删除操作

```c
/**************************************/  
/* 函数功能:栈(顺序存储)的删除操作         */
/* 函数参数:sequence_stack类型的指针     */
/* 函数返回值:无                        */
/* 文件名:seqstack.c,函数名:pop()       */  
/**************************************/
void pop(sequence_stack *st){
	if (st->top == 0){
		printf("The sequence stack is empty!");
		exit(1);
	}
	st->top--;
}
```

### 3.4 栈的应用

#### 括号匹配

从左向右扫描，将遇到的开括号存放至栈中，当遇到一个闭括号时，就查看这个栈的栈顶节点，如它们匹配，则删除栈顶节点，继续向右扫描；若不匹配，则说明表达式的括号不是匹配的；若扫描整个表达式后，这个栈是空的，则说明表达式中的括号是匹配的，否则表达式中的括号是不匹配的。算法如下：

```c
/*****************************************************/
/* 函数功能:判断表达式中括号是否匹配                       */
/* 函数参数:char类型数组c                               */
/* 函数返回值:int类型。返回1为匹配，返回0为不匹配           */
/* 文件名:seqmatch.c,函数名:match_kuohao()             */
/*****************************************************/
int pd(char s[]) {  
    int i=0;  
    sequence_stack st;  
    init(&st);  
    while (s[i]!='#') {  
        switch (s[i]) {  
            case '{':  
            case '[':  
            case '(':push(&st, s[i]);break;  
            case '}':if (!empty(st) && find(st)=='{'){pop(&st);break;}  
                else return 0;  
            case ')':if (!empty(st) && find(st)=='('){pop(&st);break;}  
                else return 0;  
            case ']':if (!empty(st) && find(st)=='['){pop(&st);break;}  
                else return 0;  
        }  
        i++;  
    }  
    return empty(st);  
}
```

**调用示例：**

```c
void main() {  
    char s[]={"{[25*(1+5)-4]/5}#"};  
    printf("%d\n", pd(&s));  
}
```

#### 表达式求值

```
做个记号，稍后再补...
```

## 4 队列

### 4.1 顺序队列及其实现

队列的顺序存储可以用一维数组表示，采用 `front` 和 `rear` 来标识队首数组下标和队尾下一个位置在数组中的下标，即 `rear` 指即将插入的节点在数组的下标。

![[00bff966010a5857568850eb9b26ec46_720.jpg]]

```c
/***************************/
/* 队列（顺序存储）的头文件    */
/* 文件名：seqqueue.h       */
/***************************/
#define MAXSIZE 100
typedef int datatype;
typedef struct{
	datatype a[MAXSIZE];
	int front;
	int rear;
}sequence_queue;
```

### 4.2 队列的重要基本操作

#### 顺序队列的初始化

```c
/***************************************/  
/* 函数功能:队列(顺序存储)初始化            */
/* 函数参数:sequence_queue类型的指针      */
/* 函数返回值：无                        */
/* 文件名:seqqueue.c,函数名:init()      */  
/**************************************/  
void init(sequence_queue *sq){  
    sq->front = sq->rear = 0;  
}
```

#### 判断顺序队列是否为空

```c
/**************************************/  
/* 函数功能:判断队列(顺序存储)是否为空      */
/* 函数参数:sequence_queue类型的变量sq   */
/* 函数返回值:int类型。1表示空,0表示非空   */
/* 文件名:seqqueue.c,函数名:empty()     */  
/**************************************/
int empty(sequence_queue sq){
	return (sq.front==sq.rear ? 1 : 0);
}
```

#### 输出顺序队列的节点值

```c
/************************************/
/* 函数功能:输出队列（顺序存储）的各节点值 */
/* 函数参数:sequence_queue类型变量sq   */
/* 函数返回值:无                      */
/* 文件名:seqqueue.c,函数名:display() */
/************************************/
void display(sequence_queue sq) {
int i;
    if (empty(sq)) printf("empty sequence_queue!\n");  
    else  
    for (int i = sq.front; i < sq.rear; i++) printf("%5d", sq.a[i]);  
}
```

#### 取得顺序队列的队首节点值

```c
/**************************************/  
/* 函数功能:读取队列(顺序存储)的队首节点值  */
/* 函数参数:sequence_queue类型变量sq     */
/* 函数返回值:datatype类型。返回队首节点值 */
/* 文件名:seqqueue.c,函数名:get()       */  
/**************************************/
datatype get(sequence_queue sq){
	if(empty(sq)){
		printf("sequence_queue is null!\n");
		exit(1);
	}
	return sq.a[sq.front];
}
```

#### 顺序队列的插入操作

```c
/**************************************/  
/* 函数功能:队列(顺序存储)的插入操作       */
/* 函数参数:sequence_queue类型的指针     */
/*         datatype类型变量x           */
/* 函数返回值:无                        */
/* 文件名:seqqueue.c,函数名:insert()    */  
/**************************************/
void insert(sequence_queue *sq,datatype x){
	int i;
	if(sq->rear == MAXSIZE){
		printf("sequence queue is full!\n");
		exit(1);
	}
	sq->a[sq->rear] = x;
	sq->rear++;
}
```

#### 顺序队列的删除操作

```c
/**************************************/  
/* 函数功能:队列(顺序存储)的删除操作       */
/* 函数参数:sequence_queue类型的指针     */
/* 函数返回值:无                        */
/* 文件名:seqqueue.c,函数名:dele()      */  
/**************************************/
void dele(sequence_queue *sq){
	if(sq->front==sq->rear){
		printf("sequence queue is null!\n");
		exit(1);
	}
	sq->front++;
}
```

### 4.3 顺序循环队列及其实现

给定一个大小为MAXSIZE的数组存储一个队列，经过若干次的插入和删除后，当队尾指针`rear=MAXSIZE`时，队列呈现满的状态，而事实上数组的前部分可能还有空闲位置，为了有效利用空间，将顺序存储的队列想象为 一个环状，把**数组中的最前面和最后面两个元素**看作**相邻**的元素，这就是**循环队列**。

>[!faq] 循环队列满与空的条件都为rear=front？
>**解决方法：**
>1. 设置一个标识，标识是由于rear增1使rear=front，或是由于front增1使rear=front，前者是队满而后者是队空；
>2. 牺牲一个数组元素的空间，即若数组的大小为MAXSIZE，则该数组所表示的循环队列最多存储MAXSIZE-1个节点，这样，循环队列满的条件是：`(rear+1)%MAXSIZE=front`,循环队列空的条件是：`rear=front`

#### 循环顺序队列的插入操作

```c
/**************************************************/  
/* 函数功能:循环队列(顺序存储)的插入操作                 */
/* 函数参数:sequence_queue类型的指针                  */
/*         datatype类型变量x                        */
/* 函数返回值:无                                     */
/* 文件名:secqinse.c,函数名:insert_sequence_cqueue() */  
/***************************************************/
void insert_sequence_cqueue(sequence_queue *sq,datatype x){
	int i;
	if((sq->rear+1)%MAXSIZE==sq->front){
		printf("sequence queue is full!\n");
		exit(1);
	}
	sq->a[sq->rear] = x;
	sq->rear=(sq->rear+1)%MAXSIZE;
}
```

#### 循环顺序队列的删除操作

```c
/*************************************************/  
/* 函数功能:循环队列(顺序存储)的删除操作               */
/* 函数参数:sequence_queue类型的指针                */
/* 函数返回值:无                                   */
/* 文件名:secqdele.c,函数名:dele_sequence_cqueue() */  
/*************************************************/
void dele_sequence_cqueue(sequence_queue *sq){
	if(sq->front==sq->rear){
		printf("sequence queue is null!\n");
		exit(1);
	}
	sq->front=(sq->front+1)%MAXSIZE;
}
```