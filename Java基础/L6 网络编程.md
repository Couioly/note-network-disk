网络之间的通信主要依靠**IP地址**，它可以唯一标识一台计算机。通过**端口**可以访问计算机上的应用程序。**IP**即互联网协议，IP地址是互联网协议提供的一种统一的地址格式，用于唯一标识网络中的**通信实体**，网络中的请求可以根据这个标识找到**具体的通信实体**。互联网协议的两个版本：

- IPv4：由4个字节大小的二进制标识IP地址
- IPv6：由16个字节表示IP地址有$2^{128}$

`localhost` 用于表示**本地设备或计算机**，对应的IPv4是 `127.0.0.1`，而IPv6是 `::1`。这些地址被称为**回送地址**，它们指向本地机器自身，当程序连接到回送地址时，表示程序与本地机器进行通信。

端口时应用程序与外界交流的**出入口**，用于**唯一标识**一个**应用程序**在通信中的位置。通过不同得端口号，不同得应用程序可以在同一个网络接口中通信。端口号得取值范围为1~65535，端口通常分为三类：

- 公认端口0~1023：被预先定义用于特定网络服务和应用；
- 注册端口1024~49151：通常被分配给用户进程或特定应用程序；
- 动态端口49152~65535：通常被动态分配给客户端应用程序。

>[!warning] 注意
>同一台机器不能有两个程序同时使用同一个端口，若端口号被占用，则当前程序将**启动失败**！

## 1 InetAddress类

`java.net`包中提供了`InetAddress`类用于代表IP地址，该类未提供公开得构造方法，而是提供**静态方法**来获取InetAddress类对象。如下：

|                    方法声明                    |                  功能描述                  |
| :----------------------------------------: | :------------------------------------: |
| `satic InetAddress getByName(String host)` | 获取host对应得InetAddress对象，host可以为主机名或IP地址 |
|    `static InetAddress getLocalHost()`     |          获取本地主机得InetAddress对象          |
|           `String getHostName()`           |             获取当前IP地址对象得主机名             |
|     `boolean isReachable(int timeout)`     |   判断在指定毫秒内是否可以联通该IP地址对应的主机，连通返回true    |
|         `String getHostAddress()`          |              获取字符串格式的IP地址              |

```java
public static void main(String[] args) throws IOException {  
    InetAddress localAddress = InetAddress.getLocalHost();  
    System.out.println("本机IP地址：" + localAddress.getHostAddress());  
    InetAddress bdAddress = InetAddress.getByName("www.baidu.com");  
    System.out.println("百度IP地址：" + bdAddress.getHostAddress());  
    System.out.println("百度主机名：" + bdAddress.getHostName());  
    System.out.println("百度是否可达：" + bdAddress.isReachable(3000));  
}
```

>[!bug] 异常处理
>上述方法中`getLocalHost()`和`isReachable()`方法必须设定抛出异常类，分别为`UnkownHostException`和`IOException`异常，其中`UnkownHostException`是`IOException`类的子类。

## 2 网络通信协议

网络通信协议存在两套参考模型：**OSI参考模型**和**TCP/IP参考模型**。ICP/IP(传输控制协议/因特网互联协议)，由于Internet网络体系结构以TCP/IP协议为核心，所以该模型应用广泛。关于网络通信协议的更多笔记前往网络安全部分——[点击跳转至 L1-5 网络基础协议](../网络安全/L1%20网安基础篇/L1-5%20网络基础协议.md)

在TCP/IP参考模型中，网络互联层和网络接入层主要用于处理网络编程和操作系统级别的功能，这些层次的内容超出了Java的设计范围，因此，基于CS架构进行Java网络编程时，主要关注的是传输层中的UDP和TCP这两个协议。

### 2.1 UDP通信

UDP是一种**无连接**的通信协议，发送端和接收端在数据传输时，**不建立逻辑连接**。UDP具有**资源消耗小、通信效率高、延迟低**的特点，通常在**音频、视频和普通数据传输**中使用。由于UDP无法保证数据的完整性，所以在传输**重要数据**时不建议使用UDP。

JDK在`java.net`包中提供了`DatagramPacket`类，该类实例对象用于**承载**发送或接收的数据。此外，JDK还提供了`DatagramSocket`类，该类可以发送和接收`Datagrampacket`数据包。

#### DatagramPacket类

`DatagramPacket`类用于**封装**UDP通信中的**数据**，DatagramPacket对象也称**报文对象**。在发送端和接收端创建DatagramPacket对象时，使用的构造方法不同：

- 接收端：DatagramPacket对象只需**接收一个字节数组**来存放接收到的数据
- 发送端：DatagramPacket对象不但要存放被发送的数据，还要指定数据的目标IP地址和端口号

**DatagramPacket类的构造方法**：

|                               构造方法                                | 说明                                                |
| :---------------------------------------------------------------: | :------------------------------------------------ |
|              `DatagramPacket(byte[] buf,int length)`              | 接收长度为length的数据包，length<=buf.length                |
|        `DatagramPacket(byte[] buf,int offset,int length)`         | offect用于指定传入数据包缓冲区buf的偏移量为offset，即从offset位置开始接收数据 |
| `DatagramPacket(byte[] buf,int length,InetAddress addr,int port)` | 将数据包数据buf中length长度的数据发送到指定主机的指定端口号                |
| `DatagramPacket(byte[] buf,int offset,InetAddress addr,int port)` | offset用于指定一个数组中发送数据的偏移量为offset，即从offset位置开始发送数据   |

**DatagramPacket类提供了一些用于操作UDP通信的方法，其中常用的方法如下：**

|            方法声明            | 功能描述               |
| :------------------------: | ------------------ |
| `InetAddress getAddress()` | 用于获取发送端或接收端的IP地址   |
|      `int getPort()`       | 用于获取发送端或者接收端的端口号   |
|     `byte[] getData()`     | 用于获取将要发送或者接收到的数据   |
|     `int getLength()`      | 用于获取要发送或者接收到的数据的长度 |

#### DatagramSocket类

DatagramSocket类用于创建UDP通信时发送端对象和接收端对象，该类用于创建发送端/接收端对象的方法如下：

|                    构造方法                     | 说明                                      |
| :-----------------------------------------: | --------------------------------------- |
|             `DatagramSocket()`              | 创建一个未绑定到任何地址和端口的DatagramSocket对象        |
|         `DatagramSocket(int port)`          | 创建一个绑定到指定端口的DatagramSocket对象            |
| `DatagramSocket(int port,InetAddress addr)` | 创建一个绑定到指定地址addr和端口port的DatagramSocket对象 |

**DatagramSocket类提供了发送和接收UDP数据报的一系列方法，如下：**

|               方法声明               | 功能描述                                                         |
| :------------------------------: | ------------------------------------------------------------ |
| `void receive(DatagramPacket p)` | 接收DatagramPacket数据报，在接收到数据之前会一直处于阻塞状态，若发送消息的长度比数据报长，则消息将会被截取 |
|  `void send(DatagramPacket p)`   | 发送DatagramPacket数据报，发送的数据报中包含将要发送的数据、数据长度、目标主机的IP地址和端口号      |
|          `void close()`          | 关闭当前的Socket，通知驱动程序释放这个Socket保留的资源                            |

>[!info] 简单理解
>DatagramSocket对象就好比快递员，它特有的IP和Port标识就好比快递员的身份ID标识一样，而DatagramPacket对象就是快递，它创建时设置的IP和端口就好比收件地址，然后有快递员socket使用电动车receive配送快递packet，若packet创建时未指定任何信息，则可以将它看作你家的快递收件箱，当你的快递来时将会放在这个收件箱里面。

| 网络组件                 | 对应比喻        | 核心对应关系                                                                                   |
| -------------------- | ----------- | ---------------------------------------------------------------------------------------- |
| `DatagramSocket`     | 带身份ID的快递员   | 1. 身份ID = 本地IP + 本地端口；<br>2. 职责：通过`send()`/`receive()`发送/接收快递；<br>3. 特性：无连接（送快递无需提前确认）   |
| `DatagramPacket`（发送） | 待寄出的快递      | 1. 内容 = 字节数组数据；<br>2. 收件信息 = 目标IP（`InetAddress`）+ 目标端口；<br>3. 依赖快递员（`socket.send()`）寄出   |
| `DatagramPacket`（接收） | 家里的快递收件箱    | 1. 容量 = 字节数组长度；<br>2. 职责：接收快递并存储内容；<br>3. 可获取寄件信息：通过`getAddress()`/`getPort()`得到发送端IP/端口 |
| `InetAddress`        | 详细地址（如XX小区） | 对应快递的“收件/寄件地址”核心标识（IP），是`DatagramPacket`地址的载体                                            |

**示例——发送端**

```java
import java.net.DatagramPacket;  
import java.net.DatagramSocket;  
import java.net.InetAddress;  
  
public class UdpSender {  
    public static void main(String[] args) throws Exception {  
        // 1. 创建UDP Socket（发送端可以不指定端口，系统自动分配）  
        DatagramSocket socket = new DatagramSocket();  
  
        // 2. 要发送的数据  
        String msg = "你好，这是UDP测试消息~";  
        byte[] buf = msg.getBytes();  
  
        // 3. 确定目标地址和端口（这里是本地接收端的地址+端口）  
        InetAddress targetIp = InetAddress.getLocalHost();  
        int targetPort = 8888;  
  
        // 👉 用“发送型构造方法”：数据+长度+目标地址+端口  
        DatagramPacket packet = new DatagramPacket(buf, buf.length, targetIp, targetPort);  
  
        // 4. 发送数据  
        socket.send(packet);  
        System.out.println("消息已发送");  
  
        // 关闭资源  
        socket.close();  
    }  
}
```

**示例——接收端**

```java
import java.net.DatagramPacket;  
import java.net.DatagramSocket;  
  
public class UdpReceiver {  
    public static void main(String[] args) throws Exception {  
        // 1. 创建UDP Socket，绑定端口8888  
        DatagramSocket socket = new DatagramSocket(8888);  
  
        // 2. 准备接收缓冲区（字节数组）  
        byte[] buf = new byte[1024];  
        // 👉 用“接收型构造方法”：指定缓冲区+接收长度  
        DatagramPacket packet = new DatagramPacket(buf, buf.length);  
  
        // 3. 接收数据（阻塞等待）  
        System.out.println("等待接收数据...");  
        socket.receive(packet); // 数据会被存入packet的缓冲区  
  
        // 👉 用DatagramPacket的方法获取信息  
        String senderIp = packet.getAddress().getHostAddress(); // 发送端IP  
        int senderPort = packet.getPort(); // 发送端端口  
        byte[] data = packet.getData(); // 接收到的字节数据  
        int dataLen = packet.getLength(); // 实际接收的数据长度  
  
        // 输出结果  
        String content = new String(data, 0, dataLen);  
        System.out.println("收到[" + senderIp + ":" + senderPort + "]的消息：" + content);  
  
        // 关闭资源  
        socket.close();  
    }  
}
```

### 2.2 TCP通信

TCP通信严格区分客户端和服务端，JDK在`java.net`包中提供了Socket类和ServerSocket类。基于TCP编程时步骤：

1. 先创建一个服务器端的ServerSocket对象，开启一个服务并等待客户端连接；
2. 然后创建一个客户端的Socket对象，并向服务端发送连接请求；
3. 服务端接收到请求后双方建立连接，使其可以正常通信。

>[!warning] 注意
>基于TCP通信时，需要由客户端去连接服务器端，而服务器端不能主动连接客户端

#### ServerSocket类

ServerSocket类的主要作用是**接收客户端的连接请求**，常见的构造方法如下：

|                           构造方法                            | 说明                                       |
| :-------------------------------------------------------: | ---------------------------------------- |
|                     `ServerSocket()`                      | 创建一个不与任何端口绑定的对象，默认没有监听任何端口，不能接收客户端的来凝结请求 |
|                 `ServerSocket(int port)`                  | 创建一个对象，并在指定的port端口上监听连接请求                |
|           `ServerSocket(int port,int backlog)`            | backlog参数用于指定最大连接数                       |
| `ServerSocket(int port,int backlog,InetAddress bingAddr)` | bingAddr参数用于指定监听发出连接请求的客户端的IP地址          |

>[!tip] 提示
>当使用第一个构造方法时，后续可以通过使用bing()方法来绑定端口信息以确保正常接收客户端请求

**ServerSocket类提供了一些用于监听来自客户端的连接请求和建立与客户端通信通道的方法如下:**

| 方法名称                                | 功能描述                                                               |
| ----------------------------------- | ------------------------------------------------------------------ |
| `Socket accept()`                   | 用于等待客户端的连接请求，在客户端完成连接之前会一直处于阻塞状态，当有客户端连接到服务器端时，就会返回一个与之对应的Socket对象 |
| `InetAddress getInetAddress()`      | 用于获取ServerSocket对象所绑定的IP地址                                         |
| `boolean isClosed()`                | 该方法用于判断ServerSocket对象是否为关闭状态，如果是关闭状态则返回true，否则返回false              |
| `void bind(SocketAddress endpoint)` | 用于将ServerSocket对象绑定到指定的IP地址和端口号，其中参数endpoint封装了IP地址和端口号            |
